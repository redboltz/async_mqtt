:last-update-label!:
:am-version: latest
:source-highlighter: rouge
:rouge-style: base16.monokai

ifdef::env-github[:am-base-path: ../../main]
ifndef::env-github[:am-base-path: ../..]
ifdef::env-github[:api-base: link:https://redboltz.github.io/async_mqtt/doc/{am-version}/html]
ifndef::env-github[:api-base: link:../api]

= Create endpoint

First, choose underlying layer.

ifdef::env-github[image::../img/layer.svg[layer structure]]
ifndef::env-github[image::layer.svg[layer structure]]

== Include header files

In order to use async_mqtt, include the following header file:
```cpp
#include <async_mqtt/all.hpp>
```

In addition, if you want to use TLS and/or Websocket, include the follwing header file. They are not included in `all.hpp`.

For TLS:
```cpp
#include <async_mqtt/predefined_layer/mqtts.hpp>
```

For Websocket
```cpp
#include <async_mqtt/predefined_layer/ws.hpp>
```

For Websocket on TLS
```cpp
#include <async_mqtt/predefined_layer/wss.hpp>
```

== mqtt

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    //                     endpoint is client  choose underlying layer
    auto amep = am::endpoint<am::role::client, am::protocol::mqtt>::create(
        am::protocol_version::v3_1_1, // choose MQTT version v3_1_1 or v5
        ioc.get_executor() // args for underlying layer (mqtt)
        // mqtt is as::basic_stream_socket<as::ip::tcp, as::io_context::executor_type>
    );
```

== mqtts

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::tls::context ctx{am::tls::context::tlsv12};
    ctx.set_verify_mode(am::tls::verify_none);
    // If you want to check server certificate, set cacert as follows.
    // ctx.load_verify_file(cacert);

    auto amep = am::endpoint<am::role::client, am::protocol::mqtts>::create(
        am::protocol_version::v5, // choose MQTT version v3_1_1 or v5
        ioc.get_executor(),  // args for underlying layer (as::ssl::stream<mqtt>)
        ctx
    );
```

NOTE: `tls` is namespace alias of `boost::asio::ssl` by default.

== ws

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    auto amep = am::endpoint<am::role::client, am::protocol::ws>::create(
        am::protocol_version::v3_1_1, // choose MQTT version v3_1_1 or v5
        ioc.get_executor()  // args for underlying layer (bs::websocket::stream<mqtt>)
    );
```


== wss

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::tls::context ctx{am::tls::context::tlsv12};
    ctx.set_verify_mode(am::tls::verify_none);
    // If you want to check server certificate, set cacert as follows.
    // ctx.load_verify_file(cacert);

    auto amep = am::endpoint<am::role::client, am::protocol::wss>::create(
        am::protocol_version::v3_1_1, // choose MQTT version v3_1_1 or v5
        ioc.get_executor(),  // args for underlying layer ( bs::websocket::stream<mqtts>)
        ctx                  // mqtts is as::ssl::stream<mqtt>
    );
```

== Layer access

|===
|Layer access | mqtt | mqtts | ws | wss

|next_layer()|TCP stream|TLS stream| WS stream | WS stream
|next_layer().next_layer()|-|TCP stream|TCP stream | TLS stream
|next_layer().next_layer().next_layer()|-|-|-|TCP stream
|lowest_layer()|TCP stream|TCP stream|TCP stream|TCP stream
|===
