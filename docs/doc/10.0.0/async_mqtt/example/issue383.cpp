#include <iostream>
#include <fstream>
#include <thread>
#include <future>
#include <utility>

using namespace std::literals;

#include <boost/asio.hpp>
namespace asio = boost::asio;
#include <async_mqtt/all.hpp>


// Use as::use_awaitable as the default completion token for am::client
using awaitable_client =
    asio::use_awaitable_t<>::as_default_on_t<
        async_mqtt::client<async_mqtt::protocol_version::v3_1_1, async_mqtt::protocol::mqtt>
    >;

using namespace std;

class mqtt_client {
public:
    explicit mqtt_client(std::string_view host,
                         std::string_view port,
                         std::string_view username = "",
                         std::string_view password = ""):
        async_client{ioc.get_executor()}, host{host}, port{port}, username{username}, password{password} {
    }
    mqtt_client(const mqtt_client& rhs) = delete;
    mqtt_client& operator=(const mqtt_client& rhs) = delete;
    mqtt_client(mqtt_client&& rhs) noexcept = delete;
    mqtt_client& operator=(mqtt_client&& rhs) noexcept = delete;
    virtual ~mqtt_client() = default;

    void start() {
        try {
            start_runner = std::jthread([this]() {
                std::cout << "start " << std::this_thread::get_id() << std::endl;
                asio::co_spawn(async_client.get_executor(), co_start(), asio::detached);
                ioc.run();
                std::cout << "ioc exit " << std::this_thread::get_id() << std::endl;
            });
        }
        catch(boost::system::system_error const& se) {
            std::cout << se.code().message() << std::endl;
        }
    }

    void stop() {
        auto disconnect_opt = async_client.async_disconnect(
            async_mqtt::v3_1_1::disconnect_packet{},
            asio::use_awaitable
        );
        ioc.stop();
    }

    [[nodiscard]] bool is_connected() { return connected; }

    void subscribe(const std::string& topic, const async_mqtt::qos qos) {
        asio::post(
            asio::bind_executor(
                ioc.get_executor(),
                [&]{
                    std::cout << "subscribe " << std::this_thread::get_id() << std::endl;
                    auto result_sub = co_subscribe(topic, qos);
                }
            ));
    }

    void publish(const std::string& topic, const std::string& payload) {
        asio::post(
            asio::bind_executor(
                ioc.get_executor(),
                [&]{
                    std::cout << "publish " << std::this_thread::get_id() << std::endl;
                    auto result_pub = co_publish(topic, payload);
                }
            ));
    }

    void receive(std::function<void(std::string, std::string)> receive_message) {
        asio::post(
            asio::bind_executor(
                ioc.get_executor(),
                [&]{
                    std::cout << "receive " << std::this_thread::get_id() << std::endl;
                    auto result_recv = co_receive(std::move(receive_message));
                }
            ));
    }

private:
    std::jthread start_runner{};
    asio::awaitable<void> co_start() {
        cout << "co_start->\n";
        auto exec = co_await asio::this_coro::executor;
        try {
            co_await async_mqtt::async_underlying_handshake(async_client.next_layer(), host, port);

            cout << "  at will\n";
            async_mqtt::will will{
                "WillTopic1",
                "WillMessage1",
                async_mqtt::qos::at_most_once,
                { // properties
                    async_mqtt::property::user_property{"key1", "val1"},
                    async_mqtt::property::content_type{"text"},
                }
            };

            cout << "  starting connect and receive loop...\n";
            // MQTT connect and receive loop start
            auto connack_opt = co_await async_client.async_start(
                async_mqtt::v3_1_1::connect_packet{
                    true,   // clean_start
                    0x1234, // keep_alive
                    "",     // Client Identifier, empty means generated by the broker
                    will,   // you can pass std::nullopt if you don't want to set the will message
                    username,
                    password
                },
                asio::use_awaitable
            );
            cout << "   ... Done!\n";

            if (connack_opt) {
                std::cout << *connack_opt << std::endl;
                connected = true;
            }
        }
        catch (boost::system::system_error const& se) {
            std::cout << se.code().message() << std::endl;
        }
    }

    asio::awaitable<void> co_subscribe(const std::string& topic, async_mqtt::qos qos) {
        cout << "co_subscribe->\n";
        std::vector<async_mqtt::topic_subopts> subscribe_entry{{topic, qos}};
        const auto subscribe_ack_opt = co_await async_client.async_subscribe(
            async_mqtt::v3_1_1::subscribe_packet{
                *async_client.acquire_unique_packet_id(),
                async_mqtt::force_move(subscribe_entry)
            },
            asio::use_awaitable
        );
        if(subscribe_ack_opt) {
            std::cout << *subscribe_ack_opt << std::endl;
        }
    }

    asio::awaitable<void> co_publish(const std::string& topic, const std::string& payload) {
        cout << "co_publish->\n";
        static auto print_result =
            [](auto const& pubres) {
                if (pubres.puback_opt) {
                    std::cout << *pubres.puback_opt << std::endl;
                }
                if (pubres.pubrec_opt) {
                    std::cout << *pubres.pubrec_opt << std::endl;
                }
                if (pubres.pubcomp_opt) {
                    std::cout << *pubres.pubcomp_opt << std::endl;
                }
        };

        const auto result = co_await async_client.async_publish(
            async_mqtt::v3_1_1::publish_packet{
                topic,
                payload,
                async_mqtt::qos::at_least_once
            },
            asio::use_awaitable
        );
        print_result(result);
    }

    asio::awaitable<void> co_receive(const std::function<void(std::string, std::string)> receive_message) {
        cout << "co_receive->\n";
        auto pv = co_await async_client.async_recv(asio::use_awaitable);
        pv.visit(
            async_mqtt::overload {
                [&](awaitable_client::publish_packet& p) {
                    receive_message(p.topic(), p.payload());
                },
                [&](awaitable_client::disconnect_packet& p) {
                    std::cout << p << std::endl;
                },
                [](auto&) {
                }
            }
        );
    }

    asio::io_context ioc{};
    awaitable_client async_client;
    std::string host;
    std::string port;
    std::string username;
    std::string password;
    std::atomic<bool> connected{false};
};

int main() {
    try {
        mqtt_client client{"127.0.0.1", "1883", "", ""};

        cout << "Starting client and wait for connected state...\n";
        client.start();
        while(!client.is_connected()) std::this_thread::sleep_for(300ms);

        cout << "Subscribe to a topic...\n";
        client.subscribe("topic1", async_mqtt::qos::at_least_once);

        client.receive([](const std::string& topic, const std::string& payload) { cout << "Received on " << topic << ": " << payload; });
        cout << "Publishing...\n";
        client.publish("topic1", "1 blah blah...");
        client.publish("topic1", "2 blah blah...");
        client.publish("topic1", "3 blah blah...");
        client.publish("topic1", "4 blah blah...");
        client.publish("topic1", "5 blah blah...");
        cout << "Listening...\n";
        client.receive([](const std::string& topic, const std::string& payload) { cout << "Received on " << topic << ": " << payload; });

        cout << "Entering wait...\n";
        for(int i=10; i>0; --i) {
            std::this_thread::sleep_for(1s);
            cout << i << " " << flush;
        }

        cout << "\nStopping client... ";
        client.stop();
        cout << "Done.\n";
    }
    catch(const std::exception& ex) {
        std::cout << "Exception: " << ex.what() << std::endl;
    }
    catch(...) {
        std::cout << "Unknown Exception!" << std::endl;
    }
    return 0;
}
