#include <iostream>

using namespace std::literals;

#include <boost/asio.hpp>
namespace asio = boost::asio;
#include <async_mqtt/all.hpp>


// Use as::use_awaitable as the default completion token for am::client
using client_t = async_mqtt::client<async_mqtt::protocol_version::v3_1_1, async_mqtt::protocol::mqtt>;

using namespace std;

class mqtt_client {
public:
    explicit mqtt_client(asio::any_io_executor exe,
                         std::string_view host,
                         std::string_view port,
                         std::string_view username = "",
                         std::string_view password = ""):
        async_client{exe}, host{host}, port{port}, username{username}, password{password} {
    }
    mqtt_client(const mqtt_client& rhs) = delete;
    mqtt_client& operator=(const mqtt_client& rhs) = delete;
    mqtt_client(mqtt_client&& rhs) noexcept = delete;
    mqtt_client& operator=(mqtt_client&& rhs) noexcept = delete;
    virtual ~mqtt_client() = default;

public:
    asio::awaitable<void> start() {
        cout << "start->\n";
        try {
            co_await async_mqtt::async_underlying_handshake(
                async_client.next_layer(),
                host,
                port,
                asio::bind_executor(async_client.get_executor(), asio::use_awaitable)
            );

            cout << "  at will\n";
            async_mqtt::will will{
                "WillTopic1",
                "WillMessage1",
                async_mqtt::qos::at_most_once,
                { // properties
                    async_mqtt::property::user_property{"key1", "val1"},
                    async_mqtt::property::content_type{"text"},
                }
            };

            cout << "  starting connect and receive loop...\n";
            // MQTT connect and receive loop start
            auto connack_opt = co_await async_client.async_start(
                async_mqtt::v3_1_1::connect_packet{
                    true,   // clean_start
                    0x1234, // keep_alive
                    "",     // Client Identifier, empty means generated by the broker
                    will,   // you can pass std::nullopt if you don't want to set the will message
                    username,
                    password
                },
                asio::bind_executor(async_client.get_executor(), asio::use_awaitable)
            );
            cout << "   ... Done!\n";

            if (connack_opt) {
                std::cout << *connack_opt << std::endl;
            }
        }
        catch (boost::system::system_error const& se) {
            std::cout << se.code().message() << std::endl;
        }
    }

    asio::awaitable<void> stop() {
        co_await async_client.async_disconnect(
            async_mqtt::v3_1_1::disconnect_packet{},
            asio::bind_executor(async_client.get_executor(), asio::use_awaitable)
        );
    }

    asio::awaitable<void> subscribe(const std::string& topic, async_mqtt::qos qos) {
        cout << "co_subscribe->\n";
        std::vector<async_mqtt::topic_subopts> subscribe_entry{{topic, qos}};
        const auto subscribe_ack_opt = co_await async_client.async_subscribe(
            async_mqtt::v3_1_1::subscribe_packet{
                *async_client.acquire_unique_packet_id(),
                async_mqtt::force_move(subscribe_entry)
            },
            asio::bind_executor(async_client.get_executor(), asio::use_awaitable)
        );
        if(subscribe_ack_opt) {
            std::cout << *subscribe_ack_opt << std::endl;
        }
    }

    asio::awaitable<void> publish(const std::string& topic, const std::string& payload) {
        cout << "co_publish->\n";
        static auto print_result =
            [](auto const& pubres) {
                if (pubres.puback_opt) {
                    std::cout << *pubres.puback_opt << std::endl;
                }
                if (pubres.pubrec_opt) {
                    std::cout << *pubres.pubrec_opt << std::endl;
                }
                if (pubres.pubcomp_opt) {
                    std::cout << *pubres.pubcomp_opt << std::endl;
                }
        };

        const auto result = co_await async_client.async_publish(
            async_mqtt::v3_1_1::publish_packet{
                *async_client.acquire_unique_packet_id(),
                topic,
                payload,
                async_mqtt::qos::at_least_once
            },
            asio::bind_executor(async_client.get_executor(), asio::use_awaitable)
        );
        print_result(result);
    }

    asio::awaitable<void> receive(const std::function<void(std::string, std::string)> receive_message) {
        cout << "co_receive->\n";
        auto pv = co_await async_client.async_recv(asio::bind_executor(async_client.get_executor(), asio::use_awaitable));
        pv.visit(
            async_mqtt::overload {
                [&](client_t::publish_packet& p) {
                    receive_message(p.topic(), p.payload());
                },
                [&](client_t::disconnect_packet& p) {
                    std::cout << p << std::endl;
                },
                [](auto&) {
                }
            }
        );
    }

    client_t async_client;
    std::string host;
    std::string port;
    std::string username;
    std::string password;
};


asio::awaitable<void> coro_main() {
    try {
        auto exe = co_await asio::this_coro::executor;
        mqtt_client client{exe, "mqtt.redboltz.net", "1883", "UserName1", "Password1"};

        cout << "Starting client and wait for connected state...\n";
        co_await client.start();

        cout << "Subscribe to a topic...\n";
        co_await client.subscribe("topic1", async_mqtt::qos::at_least_once);

        cout << "Publishing...\n";
        co_await client.publish("topic1", "1 blah blah...");
        co_await client.publish("topic1", "2 blah blah...");
        co_await client.publish("topic1", "3 blah blah...");
        co_await client.publish("topic1", "4 blah blah...");
        co_await client.publish("topic1", "5 blah blah...");
        cout << "Listening...\n";
        co_await client.receive([](const std::string& topic, const std::string& payload) { cout << "Received on " << topic << ": " << payload; });
        co_await client.receive([](const std::string& topic, const std::string& payload) { cout << "Received on " << topic << ": " << payload; });
        co_await client.receive([](const std::string& topic, const std::string& payload) { cout << "Received on " << topic << ": " << payload; });
        co_await client.receive([](const std::string& topic, const std::string& payload) { cout << "Received on " << topic << ": " << payload; });
        co_await client.receive([](const std::string& topic, const std::string& payload) { cout << "Received on " << topic << ": " << payload; });

        cout << "\nStopping client... ";
        co_await client.stop();
        cout << "Done.\n";
    }
    catch(const std::exception& ex) {
        std::cout << "Exception: " << ex.what() << std::endl;
    }
    catch(...) {
        std::cout << "Unknown Exception!" << std::endl;
    }
    co_return;
}

int main() {
    asio::io_context ioc;
    asio::co_spawn(
        ioc.get_executor(),
        coro_main(),
        asio::detached
    );
    ioc.run();
}
