<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>async_mqtt: async_mqtt::buffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">async_mqtt<span id="projectnumber">&#160;8.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classasync__mqtt_1_1buffer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classasync__mqtt_1_1buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">async_mqtt::buffer Class Reference<div class="ingroups"><a class="el" href="group__packet.html">MQTT packets</a> &raquo; <a class="el" href="group__packet__detail.html">implementation class</a> &raquo; <a class="el" href="group__buffer.html">Reference counting immutable buffer</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>buffer that has string_view interface and shared ownership This class is only for advanced usecase such as developping high performance MQTT broker. Typical MQTT client developpers don't need to care about the buffer. This class provides string_view interface. This class holds string_view pointee's lifetime optionally.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a322bad7e07196362bf2fa26d9c2b4f4f" id="r_a322bad7e07196362bf2fa26d9c2b4f4f"><td class="memItemLeft" align="right" valign="top"><a id="a322bad7e07196362bf2fa26d9c2b4f4f" name="a322bad7e07196362bf2fa26d9c2b4f4f"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b> () noexcept=default</td></tr>
<tr class="memdesc:a322bad7e07196362bf2fa26d9c2b4f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:a322bad7e07196362bf2fa26d9c2b4f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088947de7fb4d32454075ca12a8cd6c5" id="r_a088947de7fb4d32454075ca12a8cd6c5"><td class="memItemLeft" align="right" valign="top"><a id="a088947de7fb4d32454075ca12a8cd6c5" name="a088947de7fb4d32454075ca12a8cd6c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;other)=default</td></tr>
<tr class="memdesc:a088947de7fb4d32454075ca12a8cd6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor <br /></td></tr>
<tr class="separator:a088947de7fb4d32454075ca12a8cd6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5fcfee9e7ed812e29ac77e991fcf24" id="r_a1b5fcfee9e7ed812e29ac77e991fcf24"><td class="memItemLeft" align="right" valign="top"><a id="a1b5fcfee9e7ed812e29ac77e991fcf24" name="a1b5fcfee9e7ed812e29ac77e991fcf24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a1b5fcfee9e7ed812e29ac77e991fcf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor <br /></td></tr>
<tr class="separator:a1b5fcfee9e7ed812e29ac77e991fcf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0373b7226007473603184e423d20c0c3" id="r_a0373b7226007473603184e423d20c0c3"><td class="memItemLeft" align="right" valign="top"><a id="a0373b7226007473603184e423d20c0c3" name="a0373b7226007473603184e423d20c0c3"></a>
<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;other)=default</td></tr>
<tr class="memdesc:a0373b7226007473603184e423d20c0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assign operator <br /></td></tr>
<tr class="separator:a0373b7226007473603184e423d20c0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9346d850d596a68325d70f5534c93694" id="r_a9346d850d596a68325d70f5534c93694"><td class="memItemLeft" align="right" valign="top"><a id="a9346d850d596a68325d70f5534c93694" name="a9346d850d596a68325d70f5534c93694"></a>
<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a9346d850d596a68325d70f5534c93694"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assign operator <br /></td></tr>
<tr class="separator:a9346d850d596a68325d70f5534c93694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dadefc440669338abeff8e8f282d45" id="r_a89dadefc440669338abeff8e8f282d45"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89dadefc440669338abeff8e8f282d45">buffer</a> (char const *s, std::size_t count)</td></tr>
<tr class="memdesc:a89dadefc440669338abeff8e8f282d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor The buffer doesn't manage the lifetime  <br /></td></tr>
<tr class="separator:a89dadefc440669338abeff8e8f282d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d4036fb9070e0be851fa133b20c9b9" id="r_a92d4036fb9070e0be851fa133b20c9b9"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d4036fb9070e0be851fa133b20c9b9">buffer</a> (char const *s)</td></tr>
<tr class="memdesc:a92d4036fb9070e0be851fa133b20c9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor The buffer doesn't manage the lifetime  <br /></td></tr>
<tr class="separator:a92d4036fb9070e0be851fa133b20c9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6354f235a64c4441d85d5874f341e2fe" id="r_a6354f235a64c4441d85d5874f341e2fe"><td class="memTemplParams" colspan="2">template&lt;typename It , typename End , typename std::enable_if_t&lt; detail::is_input_iterator&lt; It &gt;::value &amp;&amp;detail::is_input_iterator&lt; End &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6354f235a64c4441d85d5874f341e2fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6354f235a64c4441d85d5874f341e2fe">buffer</a> (It first, End last)</td></tr>
<tr class="memdesc:a6354f235a64c4441d85d5874f341e2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assign operator The buffer doesn't manage the lifetime. The memory between first and last must be continuous.  <br /></td></tr>
<tr class="separator:a6354f235a64c4441d85d5874f341e2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ec6154fe9b524a5722848ea21fa7e0" id="r_ac8ec6154fe9b524a5722848ea21fa7e0"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8ec6154fe9b524a5722848ea21fa7e0">buffer</a> (std::string_view sv)</td></tr>
<tr class="memdesc:ac8ec6154fe9b524a5722848ea21fa7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::string_view constructor  <br /></td></tr>
<tr class="separator:ac8ec6154fe9b524a5722848ea21fa7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b4b37514e88ef089ef7b52b8293d0d" id="r_a24b4b37514e88ef089ef7b52b8293d0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24b4b37514e88ef089ef7b52b8293d0d">buffer</a> (std::string s)</td></tr>
<tr class="memdesc:a24b4b37514e88ef089ef7b52b8293d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">string constructor  <br /></td></tr>
<tr class="separator:a24b4b37514e88ef089ef7b52b8293d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fb8cd69efe05757c164e8c87d0b76c" id="r_a55fb8cd69efe05757c164e8c87d0b76c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55fb8cd69efe05757c164e8c87d0b76c">buffer</a> (std::string_view sv, std::shared_ptr&lt; void &gt; life)</td></tr>
<tr class="memdesc:a55fb8cd69efe05757c164e8c87d0b76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::string_view and lifetime constructor  <br /></td></tr>
<tr class="separator:a55fb8cd69efe05757c164e8c87d0b76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55447262777041aa99c4c260382670fc" id="r_a55447262777041aa99c4c260382670fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55447262777041aa99c4c260382670fc">buffer</a> (char const *s, std::size_t count, std::shared_ptr&lt; void &gt; life)</td></tr>
<tr class="memdesc:a55447262777041aa99c4c260382670fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer, size, and lifetime constructor  <br /></td></tr>
<tr class="separator:a55447262777041aa99c4c260382670fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb1698f2803378a97b415e53b9f6a1c" id="r_aceb1698f2803378a97b415e53b9f6a1c"><td class="memTemplParams" colspan="2">template&lt;typename It , typename End , typename std::enable_if_t&lt; detail::is_input_iterator&lt; It &gt;::value &amp;&amp;detail::is_input_iterator&lt; End &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aceb1698f2803378a97b415e53b9f6a1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aceb1698f2803378a97b415e53b9f6a1c">buffer</a> (It first, End last, std::shared_ptr&lt; void &gt; life)</td></tr>
<tr class="memdesc:aceb1698f2803378a97b415e53b9f6a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">range and lifetime constructor  <br /></td></tr>
<tr class="separator:aceb1698f2803378a97b415e53b9f6a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da7f19412f5299b994d39fba3b7fc52" id="r_a8da7f19412f5299b994d39fba3b7fc52"><td class="memItemLeft" align="right" valign="top">constexpr const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8da7f19412f5299b994d39fba3b7fc52">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a8da7f19412f5299b994d39fba3b7fc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an iterator to the beginning  <br /></td></tr>
<tr class="separator:a8da7f19412f5299b994d39fba3b7fc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f235c10fb94b0cab026d59908f8285d" id="r_a8f235c10fb94b0cab026d59908f8285d"><td class="memItemLeft" align="right" valign="top">constexpr const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f235c10fb94b0cab026d59908f8285d">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a8f235c10fb94b0cab026d59908f8285d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an iterator to the beginning  <br /></td></tr>
<tr class="separator:a8f235c10fb94b0cab026d59908f8285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5813d17def864882cac42d1f453308" id="r_a6c5813d17def864882cac42d1f453308"><td class="memItemLeft" align="right" valign="top">constexpr const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c5813d17def864882cac42d1f453308">end</a> () const noexcept</td></tr>
<tr class="memdesc:a6c5813d17def864882cac42d1f453308"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an iterator to the end  <br /></td></tr>
<tr class="separator:a6c5813d17def864882cac42d1f453308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0fddafd68f9a02bf999e13b46dce50" id="r_a6c0fddafd68f9a02bf999e13b46dce50"><td class="memItemLeft" align="right" valign="top">constexpr const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c0fddafd68f9a02bf999e13b46dce50">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a6c0fddafd68f9a02bf999e13b46dce50"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an iterator to the end  <br /></td></tr>
<tr class="separator:a6c0fddafd68f9a02bf999e13b46dce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114d7ad7bdf186c19ead1682e8a29ab6" id="r_a114d7ad7bdf186c19ead1682e8a29ab6"><td class="memItemLeft" align="right" valign="top">constexpr const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a114d7ad7bdf186c19ead1682e8a29ab6">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a114d7ad7bdf186c19ead1682e8a29ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reverse terator to the beginning  <br /></td></tr>
<tr class="separator:a114d7ad7bdf186c19ead1682e8a29ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ed7db78da4b1cd5f8de8acab7a7bbe" id="r_a92ed7db78da4b1cd5f8de8acab7a7bbe"><td class="memItemLeft" align="right" valign="top">constexpr const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92ed7db78da4b1cd5f8de8acab7a7bbe">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a92ed7db78da4b1cd5f8de8acab7a7bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reverse terator to the beginning  <br /></td></tr>
<tr class="separator:a92ed7db78da4b1cd5f8de8acab7a7bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae474cca6eba0e784c1985bf0e61940e4" id="r_ae474cca6eba0e784c1985bf0e61940e4"><td class="memItemLeft" align="right" valign="top">constexpr const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae474cca6eba0e784c1985bf0e61940e4">rend</a> () const noexcept</td></tr>
<tr class="memdesc:ae474cca6eba0e784c1985bf0e61940e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reverse terator to the end  <br /></td></tr>
<tr class="separator:ae474cca6eba0e784c1985bf0e61940e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa80c740527fd62f738cc271bc9c702" id="r_affa80c740527fd62f738cc271bc9c702"><td class="memItemLeft" align="right" valign="top">constexpr const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affa80c740527fd62f738cc271bc9c702">crend</a> () const noexcept</td></tr>
<tr class="memdesc:affa80c740527fd62f738cc271bc9c702"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reverse terator to the end  <br /></td></tr>
<tr class="separator:affa80c740527fd62f738cc271bc9c702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1856703f5cd06e90f23a52281b92b700" id="r_a1856703f5cd06e90f23a52281b92b700"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1856703f5cd06e90f23a52281b92b700">operator[]</a> (size_type pos) const</td></tr>
<tr class="memdesc:a1856703f5cd06e90f23a52281b92b700"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference of the specific character  <br /></td></tr>
<tr class="separator:a1856703f5cd06e90f23a52281b92b700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad876c3edb8c22366e1cbc2c0aee9aa03" id="r_ad876c3edb8c22366e1cbc2c0aee9aa03"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad876c3edb8c22366e1cbc2c0aee9aa03">at</a> (size_type pos) const</td></tr>
<tr class="memdesc:ad876c3edb8c22366e1cbc2c0aee9aa03"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference of the specific character with bounds checking  <br /></td></tr>
<tr class="separator:ad876c3edb8c22366e1cbc2c0aee9aa03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac343b34db354481dc49050166c399f" id="r_acac343b34db354481dc49050166c399f"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acac343b34db354481dc49050166c399f">front</a> () const</td></tr>
<tr class="memdesc:acac343b34db354481dc49050166c399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference of the first character  <br /></td></tr>
<tr class="separator:acac343b34db354481dc49050166c399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cd74134e40075e57dc00cd9e08c703" id="r_a83cd74134e40075e57dc00cd9e08c703"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83cd74134e40075e57dc00cd9e08c703">back</a> () const</td></tr>
<tr class="memdesc:a83cd74134e40075e57dc00cd9e08c703"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference of the last character  <br /></td></tr>
<tr class="separator:a83cd74134e40075e57dc00cd9e08c703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbd3a5eefbf1dd4e572fdf1fe9d6a86" id="r_aacbd3a5eefbf1dd4e572fdf1fe9d6a86"><td class="memItemLeft" align="right" valign="top">constexpr const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacbd3a5eefbf1dd4e572fdf1fe9d6a86">data</a> () const noexcept</td></tr>
<tr class="memdesc:aacbd3a5eefbf1dd4e572fdf1fe9d6a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer of the first character of the buffer  <br /></td></tr>
<tr class="separator:aacbd3a5eefbf1dd4e572fdf1fe9d6a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e30bb89d7851e7a5568b22ef7912838" id="r_a6e30bb89d7851e7a5568b22ef7912838"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e30bb89d7851e7a5568b22ef7912838">size</a> () const noexcept</td></tr>
<tr class="memdesc:a6e30bb89d7851e7a5568b22ef7912838"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of characters  <br /></td></tr>
<tr class="separator:a6e30bb89d7851e7a5568b22ef7912838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848e929b62ec91b0a8c3cd902692d944" id="r_a848e929b62ec91b0a8c3cd902692d944"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a848e929b62ec91b0a8c3cd902692d944">length</a> () const noexcept</td></tr>
<tr class="memdesc:a848e929b62ec91b0a8c3cd902692d944"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of characters  <br /></td></tr>
<tr class="separator:a848e929b62ec91b0a8c3cd902692d944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb5b7e300fc71f9e8b7d78400e9f411" id="r_aabb5b7e300fc71f9e8b7d78400e9f411"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabb5b7e300fc71f9e8b7d78400e9f411">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:aabb5b7e300fc71f9e8b7d78400e9f411"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the largeset possible number of the buffer  <br /></td></tr>
<tr class="separator:aabb5b7e300fc71f9e8b7d78400e9f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6ec08901878976a702825394f24540" id="r_a5a6ec08901878976a702825394f24540"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a6ec08901878976a702825394f24540">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a5a6ec08901878976a702825394f24540"><td class="mdescLeft">&#160;</td><td class="mdescRight">checking the buffer is empty  <br /></td></tr>
<tr class="separator:a5a6ec08901878976a702825394f24540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b4cc2dd0ffb3edcf65361f8e12a62d" id="r_a32b4cc2dd0ffb3edcf65361f8e12a62d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32b4cc2dd0ffb3edcf65361f8e12a62d">remove_prefix</a> (size_type n)</td></tr>
<tr class="memdesc:a32b4cc2dd0ffb3edcf65361f8e12a62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the first n characters from the buffer  <br /></td></tr>
<tr class="separator:a32b4cc2dd0ffb3edcf65361f8e12a62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423e1a01c90d85823a943dab3aa364f9" id="r_a423e1a01c90d85823a943dab3aa364f9"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a423e1a01c90d85823a943dab3aa364f9">remove_suffix</a> (size_type n)</td></tr>
<tr class="memdesc:a423e1a01c90d85823a943dab3aa364f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the last n characters from the buffer  <br /></td></tr>
<tr class="separator:a423e1a01c90d85823a943dab3aa364f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5d131740b5cb75e29f174db8c08218" id="r_a5d5d131740b5cb75e29f174db8c08218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d5d131740b5cb75e29f174db8c08218">swap</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> &amp;buf) noexcept</td></tr>
<tr class="memdesc:a5d5d131740b5cb75e29f174db8c08218"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the buffer  <br /></td></tr>
<tr class="separator:a5d5d131740b5cb75e29f174db8c08218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9554ca7b3e648e0d6a07b3a5c37c95a6" id="r_a9554ca7b3e648e0d6a07b3a5c37c95a6"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9554ca7b3e648e0d6a07b3a5c37c95a6">copy</a> (char *dest, size_type count, size_type pos=0) const</td></tr>
<tr class="memdesc:a9554ca7b3e648e0d6a07b3a5c37c95a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy the buffer characters  <br /></td></tr>
<tr class="separator:a9554ca7b3e648e0d6a07b3a5c37c95a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7895963705a5671147e3cfb366f48756" id="r_a7895963705a5671147e3cfb366f48756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7895963705a5671147e3cfb366f48756">substr</a> (size_type pos=0, size_type count=npos) const &amp;</td></tr>
<tr class="memdesc:a7895963705a5671147e3cfb366f48756"><td class="mdescLeft">&#160;</td><td class="mdescRight">get substring The returned buffer ragnge is the same as std::string_view::substr(). In addition the lifetime is shared between returned buffer and this buffer.  <br /></td></tr>
<tr class="separator:a7895963705a5671147e3cfb366f48756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d64b3893dfec271b87d8f2e3dd6b65" id="r_ad3d64b3893dfec271b87d8f2e3dd6b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3d64b3893dfec271b87d8f2e3dd6b65">substr</a> (size_type pos=0, size_type count=npos) &amp;&amp;</td></tr>
<tr class="memdesc:ad3d64b3893dfec271b87d8f2e3dd6b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">get substring The returned buffer ragnge is the same as std::string_view::substr(). In addition the lifetime is moved to returned buffer.  <br /></td></tr>
<tr class="separator:ad3d64b3893dfec271b87d8f2e3dd6b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b3127002e0a9f2f0641ecad4daea24" id="r_aa7b3127002e0a9f2f0641ecad4daea24"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7b3127002e0a9f2f0641ecad4daea24">compare</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf) const noexcept</td></tr>
<tr class="memdesc:aa7b3127002e0a9f2f0641ecad4daea24"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:aa7b3127002e0a9f2f0641ecad4daea24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3256c4c867f85ebbe95ac1f83381a2a" id="r_ae3256c4c867f85ebbe95ac1f83381a2a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3256c4c867f85ebbe95ac1f83381a2a">compare</a> (std::string_view const &amp;v) const noexcept</td></tr>
<tr class="memdesc:ae3256c4c867f85ebbe95ac1f83381a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:ae3256c4c867f85ebbe95ac1f83381a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87697e3a25d39f5cf79f86c0ceed63a" id="r_aa87697e3a25d39f5cf79f86c0ceed63a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa87697e3a25d39f5cf79f86c0ceed63a">compare</a> (size_type pos1, size_type count1, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf) const noexcept</td></tr>
<tr class="memdesc:aa87697e3a25d39f5cf79f86c0ceed63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:aa87697e3a25d39f5cf79f86c0ceed63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeea408cf2d0d3c90d1b36b7cdd3bc60" id="r_afeea408cf2d0d3c90d1b36b7cdd3bc60"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeea408cf2d0d3c90d1b36b7cdd3bc60">compare</a> (size_type pos1, size_type count1, std::string_view const &amp;v) const noexcept</td></tr>
<tr class="memdesc:afeea408cf2d0d3c90d1b36b7cdd3bc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:afeea408cf2d0d3c90d1b36b7cdd3bc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f450efa2f2cd9b99b9eeb734fae6ce" id="r_a54f450efa2f2cd9b99b9eeb734fae6ce"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54f450efa2f2cd9b99b9eeb734fae6ce">compare</a> (size_type pos1, size_type count1, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf, size_type pos2, size_type count2) const noexcept</td></tr>
<tr class="memdesc:a54f450efa2f2cd9b99b9eeb734fae6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:a54f450efa2f2cd9b99b9eeb734fae6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0285c947c7bbbffa30f1fb308647a7" id="r_a5b0285c947c7bbbffa30f1fb308647a7"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b0285c947c7bbbffa30f1fb308647a7">compare</a> (size_type pos1, size_type count1, std::string_view const &amp;v, size_type pos2, size_type count2) const noexcept</td></tr>
<tr class="memdesc:a5b0285c947c7bbbffa30f1fb308647a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:a5b0285c947c7bbbffa30f1fb308647a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc5067111459a6bd4877bf1259a4d5b" id="r_afdc5067111459a6bd4877bf1259a4d5b"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc5067111459a6bd4877bf1259a4d5b">compare</a> (char const *s) const noexcept</td></tr>
<tr class="memdesc:afdc5067111459a6bd4877bf1259a4d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:afdc5067111459a6bd4877bf1259a4d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e5f60628b2fd9845e849f4c694f40a" id="r_a33e5f60628b2fd9845e849f4c694f40a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33e5f60628b2fd9845e849f4c694f40a">compare</a> (size_type pos1, size_type count1, char const *s) const noexcept</td></tr>
<tr class="memdesc:a33e5f60628b2fd9845e849f4c694f40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:a33e5f60628b2fd9845e849f4c694f40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88206280e6d162885e24543f3149537c" id="r_a88206280e6d162885e24543f3149537c"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88206280e6d162885e24543f3149537c">compare</a> (size_type pos1, size_type count1, char const *s, size_type pos2, size_type count2) const noexcept</td></tr>
<tr class="memdesc:a88206280e6d162885e24543f3149537c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare buffer Compare only the view.  <br /></td></tr>
<tr class="separator:a88206280e6d162885e24543f3149537c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269bf3927431f407bf18859cf5d4ea16" id="r_a269bf3927431f407bf18859cf5d4ea16"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a269bf3927431f407bf18859cf5d4ea16">find</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:a269bf3927431f407bf18859cf5d4ea16"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first substring equal to the given view  <br /></td></tr>
<tr class="separator:a269bf3927431f407bf18859cf5d4ea16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85319fe0ea175220596437df5e8ab4b" id="r_ab85319fe0ea175220596437df5e8ab4b"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab85319fe0ea175220596437df5e8ab4b">find</a> (std::string_view v, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:ab85319fe0ea175220596437df5e8ab4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first substring equal to the given view  <br /></td></tr>
<tr class="separator:ab85319fe0ea175220596437df5e8ab4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdcf270dd250f87a467c0a9e68525dc" id="r_abfdcf270dd250f87a467c0a9e68525dc"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfdcf270dd250f87a467c0a9e68525dc">find</a> (char ch, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:abfdcf270dd250f87a467c0a9e68525dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first substring equal to the given view  <br /></td></tr>
<tr class="separator:abfdcf270dd250f87a467c0a9e68525dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5421e369b822908736fd3a1f4d77fe5e" id="r_a5421e369b822908736fd3a1f4d77fe5e"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5421e369b822908736fd3a1f4d77fe5e">find</a> (char const *s, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:a5421e369b822908736fd3a1f4d77fe5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first substring equal to the given view  <br /></td></tr>
<tr class="separator:a5421e369b822908736fd3a1f4d77fe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1837a1661fa939b84149c8a9588cc2e0" id="r_a1837a1661fa939b84149c8a9588cc2e0"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1837a1661fa939b84149c8a9588cc2e0">find</a> (char const *s, size_type pos=0) const</td></tr>
<tr class="memdesc:a1837a1661fa939b84149c8a9588cc2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first substring equal to the given view  <br /></td></tr>
<tr class="separator:a1837a1661fa939b84149c8a9588cc2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10863870aa464f6a509b5039404e1aa6" id="r_a10863870aa464f6a509b5039404e1aa6"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10863870aa464f6a509b5039404e1aa6">rfind</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:a10863870aa464f6a509b5039404e1aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last substring equal to the given view  <br /></td></tr>
<tr class="separator:a10863870aa464f6a509b5039404e1aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afd4a601f932e7f09013dd9c3a4d211" id="r_a9afd4a601f932e7f09013dd9c3a4d211"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9afd4a601f932e7f09013dd9c3a4d211">rfind</a> (std::string_view v, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:a9afd4a601f932e7f09013dd9c3a4d211"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last substring equal to the given view  <br /></td></tr>
<tr class="separator:a9afd4a601f932e7f09013dd9c3a4d211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2379c0aa302383e2b8711b1fed57701" id="r_ae2379c0aa302383e2b8711b1fed57701"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2379c0aa302383e2b8711b1fed57701">rfind</a> (char ch, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:ae2379c0aa302383e2b8711b1fed57701"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last substring equal to the given view  <br /></td></tr>
<tr class="separator:ae2379c0aa302383e2b8711b1fed57701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bdf0c7d13724a34e5e5d87b98b08e0" id="r_a88bdf0c7d13724a34e5e5d87b98b08e0"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88bdf0c7d13724a34e5e5d87b98b08e0">rfind</a> (char const *s, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:a88bdf0c7d13724a34e5e5d87b98b08e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last substring equal to the given view  <br /></td></tr>
<tr class="separator:a88bdf0c7d13724a34e5e5d87b98b08e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f24316808f123dfc1b1fb82136f553" id="r_a71f24316808f123dfc1b1fb82136f553"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71f24316808f123dfc1b1fb82136f553">rfind</a> (char const *s, size_type pos=npos) const</td></tr>
<tr class="memdesc:a71f24316808f123dfc1b1fb82136f553"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last substring equal to the given view  <br /></td></tr>
<tr class="separator:a71f24316808f123dfc1b1fb82136f553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d0f456beae3bd6c59c744337ffb5a8" id="r_af2d0f456beae3bd6c59c744337ffb5a8"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2d0f456beae3bd6c59c744337ffb5a8">find_first_of</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:af2d0f456beae3bd6c59c744337ffb5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:af2d0f456beae3bd6c59c744337ffb5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46560e774f670ed2d881c98ec0230c91" id="r_a46560e774f670ed2d881c98ec0230c91"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46560e774f670ed2d881c98ec0230c91">find_first_of</a> (std::string_view v, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:a46560e774f670ed2d881c98ec0230c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a46560e774f670ed2d881c98ec0230c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab257a32ccbdbb3b6fc644ce667c5f0da" id="r_ab257a32ccbdbb3b6fc644ce667c5f0da"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab257a32ccbdbb3b6fc644ce667c5f0da">find_first_of</a> (char ch, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:ab257a32ccbdbb3b6fc644ce667c5f0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:ab257a32ccbdbb3b6fc644ce667c5f0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcc276cd25eb222d707c7da90183608" id="r_a7fcc276cd25eb222d707c7da90183608"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fcc276cd25eb222d707c7da90183608">find_first_of</a> (char const *s, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:a7fcc276cd25eb222d707c7da90183608"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a7fcc276cd25eb222d707c7da90183608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14120395e1b853753b61b3458bd87d8" id="r_ac14120395e1b853753b61b3458bd87d8"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac14120395e1b853753b61b3458bd87d8">find_first_of</a> (char const *s, size_type pos=0) const</td></tr>
<tr class="memdesc:ac14120395e1b853753b61b3458bd87d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:ac14120395e1b853753b61b3458bd87d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ccbd06d151e57f5d88ae5434d1f057" id="r_a95ccbd06d151e57f5d88ae5434d1f057"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ccbd06d151e57f5d88ae5434d1f057">find_last_of</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:a95ccbd06d151e57f5d88ae5434d1f057"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a95ccbd06d151e57f5d88ae5434d1f057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f0dd20db70357b5280f48ae82db09a" id="r_a86f0dd20db70357b5280f48ae82db09a"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86f0dd20db70357b5280f48ae82db09a">find_last_of</a> (std::string_view v, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:a86f0dd20db70357b5280f48ae82db09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a86f0dd20db70357b5280f48ae82db09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23320f42eb2c652180ba2bf8a93e01f9" id="r_a23320f42eb2c652180ba2bf8a93e01f9"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23320f42eb2c652180ba2bf8a93e01f9">find_last_of</a> (char ch, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:a23320f42eb2c652180ba2bf8a93e01f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a23320f42eb2c652180ba2bf8a93e01f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa779199f5fdca4f2fb5bdfd33ea00869" id="r_aa779199f5fdca4f2fb5bdfd33ea00869"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa779199f5fdca4f2fb5bdfd33ea00869">find_last_of</a> (char const *s, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:aa779199f5fdca4f2fb5bdfd33ea00869"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:aa779199f5fdca4f2fb5bdfd33ea00869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8412369bdf77e8578bab6c04b857aa3a" id="r_a8412369bdf77e8578bab6c04b857aa3a"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8412369bdf77e8578bab6c04b857aa3a">find_last_of</a> (char const *s, size_type pos=npos) const</td></tr>
<tr class="memdesc:a8412369bdf77e8578bab6c04b857aa3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a8412369bdf77e8578bab6c04b857aa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a12857383c8b812b3b9856d1f0080" id="r_add2a12857383c8b812b3b9856d1f0080"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add2a12857383c8b812b3b9856d1f0080">find_first_not_of</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:add2a12857383c8b812b3b9856d1f0080"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:add2a12857383c8b812b3b9856d1f0080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d69fb8ed6bac921784b5fe47fc81a9" id="r_a19d69fb8ed6bac921784b5fe47fc81a9"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d69fb8ed6bac921784b5fe47fc81a9">find_first_not_of</a> (std::string_view v, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:a19d69fb8ed6bac921784b5fe47fc81a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a19d69fb8ed6bac921784b5fe47fc81a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e310286c1d17d756753b59f5b1b62a9" id="r_a0e310286c1d17d756753b59f5b1b62a9"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e310286c1d17d756753b59f5b1b62a9">find_first_not_of</a> (char ch, size_type pos=0) const noexcept</td></tr>
<tr class="memdesc:a0e310286c1d17d756753b59f5b1b62a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a0e310286c1d17d756753b59f5b1b62a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0f4a342d1e87f409dd4ffdac5c9b9e" id="r_afe0f4a342d1e87f409dd4ffdac5c9b9e"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe0f4a342d1e87f409dd4ffdac5c9b9e">find_first_not_of</a> (char const *s, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:afe0f4a342d1e87f409dd4ffdac5c9b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:afe0f4a342d1e87f409dd4ffdac5c9b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cf72c6074687c8b4ba9e06f5b75dcf" id="r_a04cf72c6074687c8b4ba9e06f5b75dcf"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04cf72c6074687c8b4ba9e06f5b75dcf">find_first_not_of</a> (char const *s, size_type pos=0) const</td></tr>
<tr class="memdesc:a04cf72c6074687c8b4ba9e06f5b75dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a04cf72c6074687c8b4ba9e06f5b75dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b450eade43961525166594c3372d00f" id="r_a9b450eade43961525166594c3372d00f"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b450eade43961525166594c3372d00f">find_last_not_of</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;buf, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:a9b450eade43961525166594c3372d00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a9b450eade43961525166594c3372d00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e549dc5d642447902ac20375709012" id="r_a46e549dc5d642447902ac20375709012"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46e549dc5d642447902ac20375709012">find_last_not_of</a> (std::string_view v, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:a46e549dc5d642447902ac20375709012"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a46e549dc5d642447902ac20375709012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8d08173e2701fa900b13edd1507333" id="r_a4b8d08173e2701fa900b13edd1507333"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b8d08173e2701fa900b13edd1507333">find_last_not_of</a> (char ch, size_type pos=npos) const noexcept</td></tr>
<tr class="memdesc:a4b8d08173e2701fa900b13edd1507333"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a4b8d08173e2701fa900b13edd1507333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875877ea75c6813f05d7a5270ce6ff67" id="r_a875877ea75c6813f05d7a5270ce6ff67"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a875877ea75c6813f05d7a5270ce6ff67">find_last_not_of</a> (char const *s, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:a875877ea75c6813f05d7a5270ce6ff67"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a875877ea75c6813f05d7a5270ce6ff67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be6aa333afd34a1f3d1f15e97f8f47e" id="r_a7be6aa333afd34a1f3d1f15e97f8f47e"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7be6aa333afd34a1f3d1f15e97f8f47e">find_last_not_of</a> (char const *s, size_type pos=npos) const</td></tr>
<tr class="memdesc:a7be6aa333afd34a1f3d1f15e97f8f47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last character not equal to any of the characters in the given view  <br /></td></tr>
<tr class="separator:a7be6aa333afd34a1f3d1f15e97f8f47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9df5707a65af78f307095c7eae86d49" id="r_ae9df5707a65af78f307095c7eae86d49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9df5707a65af78f307095c7eae86d49">operator as::const_buffer</a> () const</td></tr>
<tr class="memdesc:ae9df5707a65af78f307095c7eae86d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">conversion operator to the buffer as asio const_buffer  <br /></td></tr>
<tr class="separator:ae9df5707a65af78f307095c7eae86d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540fede2026bcc5d63fbce9ba1b44a4a" id="r_a540fede2026bcc5d63fbce9ba1b44a4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a540fede2026bcc5d63fbce9ba1b44a4a">operator std::string_view</a> () const</td></tr>
<tr class="memdesc:a540fede2026bcc5d63fbce9ba1b44a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">conversion operator to the buffer as asio const_buffer  <br /></td></tr>
<tr class="separator:a540fede2026bcc5d63fbce9ba1b44a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74f79097bbf0ea1f5eadfed3ffc0b88" id="r_ae74f79097bbf0ea1f5eadfed3ffc0b88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae74f79097bbf0ea1f5eadfed3ffc0b88">has_life</a> () const noexcept</td></tr>
<tr class="memdesc:ae74f79097bbf0ea1f5eadfed3ffc0b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">life checking  <br /></td></tr>
<tr class="separator:ae74f79097bbf0ea1f5eadfed3ffc0b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a34f8afa0202115a159b4f5ea6b94be4d" id="r_a34f8afa0202115a159b4f5ea6b94be4d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34f8afa0202115a159b4f5ea6b94be4d">operator==</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;lhs, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a34f8afa0202115a159b4f5ea6b94be4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">equal operator comparison target is the view of the buffer. life holder is not compared.  <br /></td></tr>
<tr class="separator:a34f8afa0202115a159b4f5ea6b94be4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1faeb6b12d6ac65682cd68ba1d885fa" id="r_aa1faeb6b12d6ac65682cd68ba1d885fa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1faeb6b12d6ac65682cd68ba1d885fa">operator!=</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;lhs, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa1faeb6b12d6ac65682cd68ba1d885fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">not equal operator comparison target is the view of the buffer. life holder is not compared.  <br /></td></tr>
<tr class="separator:aa1faeb6b12d6ac65682cd68ba1d885fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc9aac9c067cd8c1ce6326713db924d" id="r_aedc9aac9c067cd8c1ce6326713db924d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedc9aac9c067cd8c1ce6326713db924d">operator&lt;</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;lhs, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aedc9aac9c067cd8c1ce6326713db924d"><td class="mdescLeft">&#160;</td><td class="mdescRight">less than operator comparison target is the view of the buffer. life holder is not compared.  <br /></td></tr>
<tr class="separator:aedc9aac9c067cd8c1ce6326713db924d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8272f30b904e1acbc6d6f67bc07dd2" id="r_acc8272f30b904e1acbc6d6f67bc07dd2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc8272f30b904e1acbc6d6f67bc07dd2">operator&lt;=</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;lhs, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acc8272f30b904e1acbc6d6f67bc07dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">less than or equal to operator comparison target is the view of the buffer. life holder is not compared.  <br /></td></tr>
<tr class="separator:acc8272f30b904e1acbc6d6f67bc07dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64041cca7eb053e9ac4ef32daaf4096" id="r_ae64041cca7eb053e9ac4ef32daaf4096"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae64041cca7eb053e9ac4ef32daaf4096">operator&gt;</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;lhs, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae64041cca7eb053e9ac4ef32daaf4096"><td class="mdescLeft">&#160;</td><td class="mdescRight">greater than operator comparison target is the view of the buffer. life holder is not compared.  <br /></td></tr>
<tr class="separator:ae64041cca7eb053e9ac4ef32daaf4096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06564e38baa836a4d0c9600085224c2b" id="r_a06564e38baa836a4d0c9600085224c2b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06564e38baa836a4d0c9600085224c2b">operator&gt;=</a> (<a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;lhs, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a06564e38baa836a4d0c9600085224c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">greater than or equal to operator comparison target is the view of the buffer. life holder is not compared.  <br /></td></tr>
<tr class="separator:a06564e38baa836a4d0c9600085224c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113f447e86af1b124f34251de5a33817" id="r_a113f447e86af1b124f34251de5a33817"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113f447e86af1b124f34251de5a33817">operator&lt;&lt;</a> (std::ostream &amp;o, <a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;v)</td></tr>
<tr class="memdesc:a113f447e86af1b124f34251de5a33817"><td class="mdescLeft">&#160;</td><td class="mdescRight">output to the stream  <br /></td></tr>
<tr class="separator:a113f447e86af1b124f34251de5a33817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>buffer that has string_view interface and shared ownership This class is only for advanced usecase such as developping high performance MQTT broker. Typical MQTT client developpers don't need to care about the buffer. This class provides string_view interface. This class holds string_view pointee's lifetime optionally. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a89dadefc440669338abeff8e8f282d45" name="a89dadefc440669338abeff8e8f282d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dadefc440669338abeff8e8f282d45">&#9670;&#160;</a></span>buffer() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor The buffer doesn't manage the lifetime </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the begin pointer of continuous memory that contains characters </td></tr>
    <tr><td class="paramname">count</td><td>the length of the continuours memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92d4036fb9070e0be851fa133b20c9b9" name="a92d4036fb9070e0be851fa133b20c9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d4036fb9070e0be851fa133b20c9b9">&#9670;&#160;</a></span>buffer() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor The buffer doesn't manage the lifetime </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the begin pointer of continuous memory that contains characters. The characters must be null terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6354f235a64c4441d85d5874f341e2fe" name="a6354f235a64c4441d85d5874f341e2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6354f235a64c4441d85d5874f341e2fe">&#9670;&#160;</a></span>buffer() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It , typename End , typename std::enable_if_t&lt; detail::is_input_iterator&lt; It &gt;::value &amp;&amp;detail::is_input_iterator&lt; End &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">End</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assign operator The buffer doesn't manage the lifetime. The memory between first and last must be continuous. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the begin pointer of continuous memory that contains characters </td></tr>
    <tr><td class="paramname">last</td><td>the end pointer of continuous memory that contains characters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8ec6154fe9b524a5722848ea21fa7e0" name="ac8ec6154fe9b524a5722848ea21fa7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ec6154fe9b524a5722848ea21fa7e0">&#9670;&#160;</a></span>buffer() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::string_view constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>std::string_view This constructor doesn't hold the sv target's lifetime. It behaves as std::string_view. Caller needs to manage the target lifetime. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24b4b37514e88ef089ef7b52b8293d0d" name="a24b4b37514e88ef089ef7b52b8293d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b4b37514e88ef089ef7b52b8293d0d">&#9670;&#160;</a></span>buffer() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>string constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55fb8cd69efe05757c164e8c87d0b76c" name="a55fb8cd69efe05757c164e8c87d0b76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fb8cd69efe05757c164e8c87d0b76c">&#9670;&#160;</a></span>buffer() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; void &gt;</td>          <td class="paramname"><span class="paramname"><em>life</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::string_view and lifetime constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>std::string_view </td></tr>
    <tr><td class="paramname">life</td><td>sv target's lifetime keeping object by shared ownership If user creates buffer via this constructor, sp's lifetime is held by the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55447262777041aa99c4c260382670fc" name="a55447262777041aa99c4c260382670fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55447262777041aa99c4c260382670fc">&#9670;&#160;</a></span>buffer() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; void &gt;</td>          <td class="paramname"><span class="paramname"><em>life</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer, size, and lifetime constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the beginning of the view </td></tr>
    <tr><td class="paramname">count</td><td>size of the view </td></tr>
    <tr><td class="paramname">life</td><td>sv target's lifetime keeping object by shared ownership If user creates buffer via this constructor, sp's lifetime is held by the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aceb1698f2803378a97b415e53b9f6a1c" name="aceb1698f2803378a97b415e53b9f6a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb1698f2803378a97b415e53b9f6a1c">&#9670;&#160;</a></span>buffer() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It , typename End , typename std::enable_if_t&lt; detail::is_input_iterator&lt; It &gt;::value &amp;&amp;detail::is_input_iterator&lt; End &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">End</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; void &gt;</td>          <td class="paramname"><span class="paramname"><em>life</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>range and lifetime constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the view </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the view </td></tr>
    <tr><td class="paramname">life</td><td>sv target's lifetime keeping object by shared ownership If user creates buffer via this constructor, sp's lifetime is held by the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad876c3edb8c22366e1cbc2c0aee9aa03" name="ad876c3edb8c22366e1cbc2c0aee9aa03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad876c3edb8c22366e1cbc2c0aee9aa03">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference async_mqtt::buffer::at </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference of the specific character with bounds checking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the position of the character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of the character </dd></dl>

</div>
</div>
<a id="a83cd74134e40075e57dc00cd9e08c703" name="a83cd74134e40075e57dc00cd9e08c703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cd74134e40075e57dc00cd9e08c703">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference async_mqtt::buffer::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference of the last character </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the character </dd></dl>

</div>
</div>
<a id="a8da7f19412f5299b994d39fba3b7fc52" name="a8da7f19412f5299b994d39fba3b7fc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da7f19412f5299b994d39fba3b7fc52">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator async_mqtt::buffer::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get an iterator to the beginning </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="a8f235c10fb94b0cab026d59908f8285d" name="a8f235c10fb94b0cab026d59908f8285d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f235c10fb94b0cab026d59908f8285d">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator async_mqtt::buffer::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get an iterator to the beginning </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="a6c0fddafd68f9a02bf999e13b46dce50" name="a6c0fddafd68f9a02bf999e13b46dce50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0fddafd68f9a02bf999e13b46dce50">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator async_mqtt::buffer::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get an iterator to the end </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="aa7b3127002e0a9f2f0641ecad4daea24" name="aa7b3127002e0a9f2f0641ecad4daea24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b3127002e0a9f2f0641ecad4daea24">&#9670;&#160;</a></span>compare() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the buf's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the buf's view. </dd></dl>

</div>
</div>
<a id="afdc5067111459a6bd4877bf1259a4d5b" name="afdc5067111459a6bd4877bf1259a4d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc5067111459a6bd4877bf1259a4d5b">&#9670;&#160;</a></span>compare() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the buf's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the buf's view. </dd></dl>

</div>
</div>
<a id="aa87697e3a25d39f5cf79f86c0ceed63a" name="aa87697e3a25d39f5cf79f86c0ceed63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87697e3a25d39f5cf79f86c0ceed63a">&#9670;&#160;</a></span>compare() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>start position of the this view </td></tr>
    <tr><td class="paramname">count1</td><td>length of the this view </td></tr>
    <tr><td class="paramname">buf</td><td>target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the buf's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the buf's view. </dd></dl>

</div>
</div>
<a id="a54f450efa2f2cd9b99b9eeb734fae6ce" name="a54f450efa2f2cd9b99b9eeb734fae6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f450efa2f2cd9b99b9eeb734fae6ce">&#9670;&#160;</a></span>compare() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>start position of the this view </td></tr>
    <tr><td class="paramname">count1</td><td>length of the this view </td></tr>
    <tr><td class="paramname">buf</td><td>target </td></tr>
    <tr><td class="paramname">pos2</td><td>start position of the buf's view </td></tr>
    <tr><td class="paramname">count2</td><td>length of the buf's view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the buf's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the buf's view. </dd></dl>

</div>
</div>
<a id="a33e5f60628b2fd9845e849f4c694f40a" name="a33e5f60628b2fd9845e849f4c694f40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e5f60628b2fd9845e849f4c694f40a">&#9670;&#160;</a></span>compare() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>start position of the this view </td></tr>
    <tr><td class="paramname">count1</td><td>length of the this view </td></tr>
    <tr><td class="paramname">s</td><td>target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the buf's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the buf's view. </dd></dl>

</div>
</div>
<a id="a88206280e6d162885e24543f3149537c" name="a88206280e6d162885e24543f3149537c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88206280e6d162885e24543f3149537c">&#9670;&#160;</a></span>compare() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>start position of the this view </td></tr>
    <tr><td class="paramname">count1</td><td>length of the this view </td></tr>
    <tr><td class="paramname">s</td><td>target </td></tr>
    <tr><td class="paramname">pos2</td><td>start position of the s </td></tr>
    <tr><td class="paramname">count2</td><td>length of the s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the buf's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the buf's view. </dd></dl>

</div>
</div>
<a id="afeea408cf2d0d3c90d1b36b7cdd3bc60" name="afeea408cf2d0d3c90d1b36b7cdd3bc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeea408cf2d0d3c90d1b36b7cdd3bc60">&#9670;&#160;</a></span>compare() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>start position of the this view </td></tr>
    <tr><td class="paramname">count1</td><td>length of the this view </td></tr>
    <tr><td class="paramname">v</td><td>target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the v's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the v's view. </dd></dl>

</div>
</div>
<a id="a5b0285c947c7bbbffa30f1fb308647a7" name="a5b0285c947c7bbbffa30f1fb308647a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0285c947c7bbbffa30f1fb308647a7">&#9670;&#160;</a></span>compare() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>start position of the this view </td></tr>
    <tr><td class="paramname">count1</td><td>length of the this view </td></tr>
    <tr><td class="paramname">v</td><td>target </td></tr>
    <tr><td class="paramname">pos2</td><td>start position of the buf's view </td></tr>
    <tr><td class="paramname">count2</td><td>length of the buf's view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the v's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the v's view. </dd></dl>

</div>
</div>
<a id="ae3256c4c867f85ebbe95ac1f83381a2a" name="ae3256c4c867f85ebbe95ac1f83381a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3256c4c867f85ebbe95ac1f83381a2a">&#9670;&#160;</a></span>compare() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int async_mqtt::buffer::compare </td>
          <td>(</td>
          <td class="paramtype">std::string_view const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare buffer Compare only the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if if this view is less that the v's view. zero the both view has the same sequences of the characters. posiative value if if this view is greater that the v's view. </dd></dl>

</div>
</div>
<a id="a9554ca7b3e648e0d6a07b3a5c37c95a6" name="a9554ca7b3e648e0d6a07b3a5c37c95a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9554ca7b3e648e0d6a07b3a5c37c95a6">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::copy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy the buffer characters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination </td></tr>
    <tr><td class="paramname">count</td><td>copy length </td></tr>
    <tr><td class="paramname">pos</td><td>copy start position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92ed7db78da4b1cd5f8de8acab7a7bbe" name="a92ed7db78da4b1cd5f8de8acab7a7bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ed7db78da4b1cd5f8de8acab7a7bbe">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator async_mqtt::buffer::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reverse terator to the beginning </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="affa80c740527fd62f738cc271bc9c702" name="affa80c740527fd62f738cc271bc9c702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa80c740527fd62f738cc271bc9c702">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator async_mqtt::buffer::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reverse terator to the end </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="aacbd3a5eefbf1dd4e572fdf1fe9d6a86" name="aacbd3a5eefbf1dd4e572fdf1fe9d6a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbd3a5eefbf1dd4e572fdf1fe9d6a86">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_pointer async_mqtt::buffer::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer of the first character of the buffer </p>
<dl class="section return"><dt>Returns</dt><dd>pointer </dd></dl>

</div>
</div>
<a id="a5a6ec08901878976a702825394f24540" name="a5a6ec08901878976a702825394f24540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6ec08901878976a702825394f24540">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool async_mqtt::buffer::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checking the buffer is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer is empty, otherwise false </dd></dl>

</div>
</div>
<a id="a6c5813d17def864882cac42d1f453308" name="a6c5813d17def864882cac42d1f453308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5813d17def864882cac42d1f453308">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator async_mqtt::buffer::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get an iterator to the end </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="a269bf3927431f407bf18859cf5d4ea16" name="a269bf3927431f407bf18859cf5d4ea16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269bf3927431f407bf18859cf5d4ea16">&#9670;&#160;</a></span>find() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring, or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="abfdcf270dd250f87a467c0a9e68525dc" name="abfdcf270dd250f87a467c0a9e68525dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfdcf270dd250f87a467c0a9e68525dc">&#9670;&#160;</a></span>find() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring, or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="a5421e369b822908736fd3a1f4d77fe5e" name="a5421e369b822908736fd3a1f4d77fe5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5421e369b822908736fd3a1f4d77fe5e">&#9670;&#160;</a></span>find() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>length of substring to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring, or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="a1837a1661fa939b84149c8a9588cc2e0" name="a1837a1661fa939b84149c8a9588cc2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1837a1661fa939b84149c8a9588cc2e0">&#9670;&#160;</a></span>find() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring, or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="ab85319fe0ea175220596437df5e8ab4b" name="ab85319fe0ea175220596437df5e8ab4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85319fe0ea175220596437df5e8ab4b">&#9670;&#160;</a></span>find() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring, or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="add2a12857383c8b812b3b9856d1f0080" name="add2a12857383c8b812b3b9856d1f0080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2a12857383c8b812b3b9856d1f0080">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a0e310286c1d17d756753b59f5b1b62a9" name="a0e310286c1d17d756753b59f5b1b62a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e310286c1d17d756753b59f5b1b62a9">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="afe0f4a342d1e87f409dd4ffdac5c9b9e" name="afe0f4a342d1e87f409dd4ffdac5c9b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0f4a342d1e87f409dd4ffdac5c9b9e">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>length of the string of characters to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a04cf72c6074687c8b4ba9e06f5b75dcf" name="a04cf72c6074687c8b4ba9e06f5b75dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cf72c6074687c8b4ba9e06f5b75dcf">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to compare </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a19d69fb8ed6bac921784b5fe47fc81a9" name="a19d69fb8ed6bac921784b5fe47fc81a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d69fb8ed6bac921784b5fe47fc81a9">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="af2d0f456beae3bd6c59c744337ffb5a8" name="af2d0f456beae3bd6c59c744337ffb5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d0f456beae3bd6c59c744337ffb5a8">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="ab257a32ccbdbb3b6fc644ce667c5f0da" name="ab257a32ccbdbb3b6fc644ce667c5f0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab257a32ccbdbb3b6fc644ce667c5f0da">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a7fcc276cd25eb222d707c7da90183608" name="a7fcc276cd25eb222d707c7da90183608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcc276cd25eb222d707c7da90183608">&#9670;&#160;</a></span>find_first_of() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>length of the string of characters to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="ac14120395e1b853753b61b3458bd87d8" name="ac14120395e1b853753b61b3458bd87d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14120395e1b853753b61b3458bd87d8">&#9670;&#160;</a></span>find_first_of() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a46560e774f670ed2d881c98ec0230c91" name="a46560e774f670ed2d881c98ec0230c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46560e774f670ed2d881c98ec0230c91">&#9670;&#160;</a></span>find_first_of() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_first_of </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a9b450eade43961525166594c3372d00f" name="a9b450eade43961525166594c3372d00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b450eade43961525166594c3372d00f">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a4b8d08173e2701fa900b13edd1507333" name="a4b8d08173e2701fa900b13edd1507333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8d08173e2701fa900b13edd1507333">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a875877ea75c6813f05d7a5270ce6ff67" name="a875877ea75c6813f05d7a5270ce6ff67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875877ea75c6813f05d7a5270ce6ff67">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to compare </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>length of the string of characters to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a7be6aa333afd34a1f3d1f15e97f8f47e" name="a7be6aa333afd34a1f3d1f15e97f8f47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be6aa333afd34a1f3d1f15e97f8f47e">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to compare </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a46e549dc5d642447902ac20375709012" name="a46e549dc5d642447902ac20375709012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e549dc5d642447902ac20375709012">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character not equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last character not equal to any of the characters in the given string, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a95ccbd06d151e57f5d88ae5434d1f057" name="a95ccbd06d151e57f5d88ae5434d1f057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ccbd06d151e57f5d88ae5434d1f057">&#9670;&#160;</a></span>find_last_of() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a23320f42eb2c652180ba2bf8a93e01f9" name="a23320f42eb2c652180ba2bf8a93e01f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23320f42eb2c652180ba2bf8a93e01f9">&#9670;&#160;</a></span>find_last_of() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="aa779199f5fdca4f2fb5bdfd33ea00869" name="aa779199f5fdca4f2fb5bdfd33ea00869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa779199f5fdca4f2fb5bdfd33ea00869">&#9670;&#160;</a></span>find_last_of() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>length of the string of characters to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a8412369bdf77e8578bab6c04b857aa3a" name="a8412369bdf77e8578bab6c04b857aa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8412369bdf77e8578bab6c04b857aa3a">&#9670;&#160;</a></span>find_last_of() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="a86f0dd20db70357b5280f48ae82db09a" name="a86f0dd20db70357b5280f48ae82db09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f0dd20db70357b5280f48ae82db09a">&#9670;&#160;</a></span>find_last_of() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::find_last_of </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last character equal to any of the characters in the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last occurrence of any character of the substring, or npos if no such character is found. </dd></dl>

</div>
</div>
<a id="acac343b34db354481dc49050166c399f" name="acac343b34db354481dc49050166c399f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac343b34db354481dc49050166c399f">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference async_mqtt::buffer::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference of the first character </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the character </dd></dl>

</div>
</div>
<a id="ae74f79097bbf0ea1f5eadfed3ffc0b88" name="ae74f79097bbf0ea1f5eadfed3ffc0b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74f79097bbf0ea1f5eadfed3ffc0b88">&#9670;&#160;</a></span>has_life()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool async_mqtt::buffer::has_life </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>life checking </p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer has life, otherwise false. </dd></dl>

</div>
</div>
<a id="a848e929b62ec91b0a8c3cd902692d944" name="a848e929b62ec91b0a8c3cd902692d944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848e929b62ec91b0a8c3cd902692d944">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the number of characters </p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters </dd></dl>

</div>
</div>
<a id="aabb5b7e300fc71f9e8b7d78400e9f411" name="aabb5b7e300fc71f9e8b7d78400e9f411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb5b7e300fc71f9e8b7d78400e9f411">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the largeset possible number of the buffer </p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters </dd></dl>

</div>
</div>
<a id="ae9df5707a65af78f307095c7eae86d49" name="ae9df5707a65af78f307095c7eae86d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9df5707a65af78f307095c7eae86d49">&#9670;&#160;</a></span>operator as::const_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::operator as::const_buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>conversion operator to the buffer as asio const_buffer </p>
<dl class="section return"><dt>Returns</dt><dd>asio boost::asio::const_buffer </dd></dl>

</div>
</div>
<a id="a540fede2026bcc5d63fbce9ba1b44a4a" name="a540fede2026bcc5d63fbce9ba1b44a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540fede2026bcc5d63fbce9ba1b44a4a">&#9670;&#160;</a></span>operator std::string_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async_mqtt::buffer::operator std::string_view </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>conversion operator to the buffer as asio const_buffer </p>
<dl class="section return"><dt>Returns</dt><dd>asio std::string_view </dd></dl>

</div>
</div>
<a id="a1856703f5cd06e90f23a52281b92b700" name="a1856703f5cd06e90f23a52281b92b700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1856703f5cd06e90f23a52281b92b700">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference async_mqtt::buffer::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference of the specific character </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the position of the character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of the character </dd></dl>

</div>
</div>
<a id="a114d7ad7bdf186c19ead1682e8a29ab6" name="a114d7ad7bdf186c19ead1682e8a29ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114d7ad7bdf186c19ead1682e8a29ab6">&#9670;&#160;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator async_mqtt::buffer::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reverse terator to the beginning </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="a32b4cc2dd0ffb3edcf65361f8e12a62d" name="a32b4cc2dd0ffb3edcf65361f8e12a62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b4cc2dd0ffb3edcf65361f8e12a62d">&#9670;&#160;</a></span>remove_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void async_mqtt::buffer::remove_prefix </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove the first n characters from the buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>remove length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a423e1a01c90d85823a943dab3aa364f9" name="a423e1a01c90d85823a943dab3aa364f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423e1a01c90d85823a943dab3aa364f9">&#9670;&#160;</a></span>remove_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void async_mqtt::buffer::remove_suffix </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove the last n characters from the buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>remove length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae474cca6eba0e784c1985bf0e61940e4" name="ae474cca6eba0e784c1985bf0e61940e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae474cca6eba0e784c1985bf0e61940e4">&#9670;&#160;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator async_mqtt::buffer::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reverse terator to the end </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="a10863870aa464f6a509b5039404e1aa6" name="a10863870aa464f6a509b5039404e1aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10863870aa464f6a509b5039404e1aa6">&#9670;&#160;</a></span>rfind() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="ae2379c0aa302383e2b8711b1fed57701" name="ae2379c0aa302383e2b8711b1fed57701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2379c0aa302383e2b8711b1fed57701">&#9670;&#160;</a></span>rfind() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::rfind </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="a88bdf0c7d13724a34e5e5d87b98b08e0" name="a88bdf0c7d13724a34e5e5d87b98b08e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bdf0c7d13724a34e5e5d87b98b08e0">&#9670;&#160;</a></span>rfind() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::rfind </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>length of substring to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="a71f24316808f123dfc1b1fb82136f553" name="a71f24316808f123dfc1b1fb82136f553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f24316808f123dfc1b1fb82136f553">&#9670;&#160;</a></span>rfind() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::rfind </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a string of characters to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="a9afd4a601f932e7f09013dd9c3a4d211" name="a9afd4a601f932e7f09013dd9c3a4d211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afd4a601f932e7f09013dd9c3a4d211">&#9670;&#160;</a></span>rfind() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::rfind </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last substring equal to the given view </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>view to search for </td></tr>
    <tr><td class="paramname">pos</td><td>position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first character of the found substring or npos if no such substring is found. </dd></dl>

</div>
</div>
<a id="a6e30bb89d7851e7a5568b22ef7912838" name="a6e30bb89d7851e7a5568b22ef7912838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e30bb89d7851e7a5568b22ef7912838">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type async_mqtt::buffer::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the number of characters </p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters </dd></dl>

</div>
</div>
<a id="ad3d64b3893dfec271b87d8f2e3dd6b65" name="ad3d64b3893dfec271b87d8f2e3dd6b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d64b3893dfec271b87d8f2e3dd6b65">&#9670;&#160;</a></span>substr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> async_mqtt::buffer::substr </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get substring The returned buffer ragnge is the same as std::string_view::substr(). In addition the lifetime is moved to returned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position of the first character </td></tr>
    <tr><td class="paramname">count</td><td>requested length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer </dd></dl>

</div>
</div>
<a id="a7895963705a5671147e3cfb366f48756" name="a7895963705a5671147e3cfb366f48756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7895963705a5671147e3cfb366f48756">&#9670;&#160;</a></span>substr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> async_mqtt::buffer::substr </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">npos</span>&#160;) const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get substring The returned buffer ragnge is the same as std::string_view::substr(). In addition the lifetime is shared between returned buffer and this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position of the first character </td></tr>
    <tr><td class="paramname">count</td><td>requested length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer </dd></dl>

</div>
</div>
<a id="a5d5d131740b5cb75e29f174db8c08218" name="a5d5d131740b5cb75e29f174db8c08218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5d131740b5cb75e29f174db8c08218">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void async_mqtt::buffer::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap the buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aa1faeb6b12d6ac65682cd68ba1d885fa" name="aa1faeb6b12d6ac65682cd68ba1d885fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1faeb6b12d6ac65682cd68ba1d885fa">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>not equal operator comparison target is the view of the buffer. life holder is not compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>compare target </td></tr>
    <tr><td class="paramname">rhs</td><td>compare target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lhs not equal to the rhs, otherwise false. </dd></dl>

</div>
</div>
<a id="aedc9aac9c067cd8c1ce6326713db924d" name="aedc9aac9c067cd8c1ce6326713db924d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc9aac9c067cd8c1ce6326713db924d">&#9670;&#160;</a></span>operator&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>less than operator comparison target is the view of the buffer. life holder is not compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>compare target </td></tr>
    <tr><td class="paramname">rhs</td><td>compare target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lhs less than the rhs, otherwise false. </dd></dl>

</div>
</div>
<a id="a113f447e86af1b124f34251de5a33817" name="a113f447e86af1b124f34251de5a33817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113f447e86af1b124f34251de5a33817">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>output to the stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramname">v</td><td>target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream </dd></dl>

</div>
</div>
<a id="acc8272f30b904e1acbc6d6f67bc07dd2" name="acc8272f30b904e1acbc6d6f67bc07dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8272f30b904e1acbc6d6f67bc07dd2">&#9670;&#160;</a></span>operator&lt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>less than or equal to operator comparison target is the view of the buffer. life holder is not compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>compare target </td></tr>
    <tr><td class="paramname">rhs</td><td>compare target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lhs less than or equal to the rhs, otherwise false. </dd></dl>

</div>
</div>
<a id="a34f8afa0202115a159b4f5ea6b94be4d" name="a34f8afa0202115a159b4f5ea6b94be4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f8afa0202115a159b4f5ea6b94be4d">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equal operator comparison target is the view of the buffer. life holder is not compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>compare target </td></tr>
    <tr><td class="paramname">rhs</td><td>compare target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lhs equal to the rhs, otherwise false. </dd></dl>

</div>
</div>
<a id="ae64041cca7eb053e9ac4ef32daaf4096" name="ae64041cca7eb053e9ac4ef32daaf4096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64041cca7eb053e9ac4ef32daaf4096">&#9670;&#160;</a></span>operator&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>greater than operator comparison target is the view of the buffer. life holder is not compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>compare target </td></tr>
    <tr><td class="paramname">rhs</td><td>compare target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lhs greater than the rhs, otherwise false. </dd></dl>

</div>
</div>
<a id="a06564e38baa836a4d0c9600085224c2b" name="a06564e38baa836a4d0c9600085224c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06564e38baa836a4d0c9600085224c2b">&#9670;&#160;</a></span>operator&gt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>greater than or equal to operator comparison target is the view of the buffer. life holder is not compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>compare target </td></tr>
    <tr><td class="paramname">rhs</td><td>compare target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lhs greater than or equal to the rhs, otherwise false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/async_mqtt/include/async_mqtt/util/<a class="el" href="buffer_8hpp_source.html">buffer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>async_mqtt</b></li><li class="navelem"><a class="el" href="classasync__mqtt_1_1buffer.html">buffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
