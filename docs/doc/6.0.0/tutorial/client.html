<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<title>Client</title>
<style>
/*! Copyright (C) 2019, TomTom (http://tomtom.com).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Extension of the AsciiDoctor CSS for AsciiDoxy.
 * Adding:
 * - Floating multipage navigation.
 */
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

/* Multipage navigation */
div#navigation {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1000;
}
div#navigation table {
    margin-bottom: 0;
}
@media screen and (min-width: 768px) {
    body.toc2 div#navigation {
        left: 15em;
    }
    body.toc2.toc-right div#navigation {
        right: 15em;
    }
}
@media screen and (min-width: 1280px) {
    body.toc2 div#navigation {
        left: 20em;
    }
    body.toc2.toc-right div#navigation {
        right: 20em;
    }
}

</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #f8f8f2;
  background-color: #272822;
}
pre.rouge .err {
  color: #272822;
  background-color: #f92672;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #75715e;
}
pre.rouge .cp {
  color: #f4bf75;
}
pre.rouge .nt {
  color: #f4bf75;
}
pre.rouge .o, pre.rouge .ow {
  color: #f8f8f2;
}
pre.rouge .p, pre.rouge .pi {
  color: #f8f8f2;
}
pre.rouge .gi {
  color: #a6e22e;
}
pre.rouge .gd {
  color: #f92672;
}
pre.rouge .gh {
  color: #66d9ef;
  background-color: #272822;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kv {
  color: #ae81ff;
}
pre.rouge .kc {
  color: #fd971f;
}
pre.rouge .kt {
  color: #fd971f;
}
pre.rouge .kd {
  color: #fd971f;
}
pre.rouge .s, pre.rouge .sb, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1 {
  color: #a6e22e;
}
pre.rouge .sa {
  color: #ae81ff;
}
pre.rouge .sr {
  color: #a1efe4;
}
pre.rouge .si {
  color: #cc6633;
}
pre.rouge .se {
  color: #cc6633;
}
pre.rouge .nn {
  color: #f4bf75;
}
pre.rouge .nc {
  color: #f4bf75;
}
pre.rouge .no {
  color: #f4bf75;
}
pre.rouge .na {
  color: #66d9ef;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #a6e22e;
}
pre.rouge .ss {
  color: #a6e22e;
}
</style>
</head>
<body class="article">
<div id="header">
<h1>Client</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="../api/classasync__mqtt_1_1client.html#details">Client</a> provides high level MQTT client APIs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_include_header_files">Include header files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To use async_mqtt, include the following header file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;async_mqtt/all.hpp&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, if you want to use TLS and/or WebSocket, include the following header files. They are not included in <code>all.hpp</code>.</p>
</div>
<div class="paragraph">
<p>For TLS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;async_mqtt/predefined_layer/mqtts.hpp&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For Websocket</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;async_mqtt/predefined_layer/ws.hpp&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For Websocket on TLS</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;async_mqtt/predefined_layer/wss.hpp&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_create_client">Create client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, choose MQTT protocol version (v3.1.1 or v5), and then choose underlying layer.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/layer.svg" alt="layer structure">
</div>
</div>
<div class="paragraph">
<p>The following namespace alias is defined in the all code example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">namespace</span> <span class="n">as</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">tls</span> <span class="o">=</span> <span class="n">as</span><span class="o">::</span><span class="n">ssl</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mqtt">mqtt</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">as</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ioc</span><span class="p">;</span>
    <span class="n">am</span><span class="o">::</span><span class="n">client</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">protocol_version</span><span class="o">::</span><span class="n">v3_1_1</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">mqtt</span><span class="o">&gt;</span> <span class="n">amcl</span><span class="p">{</span>
        <span class="n">ioc</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()</span> <span class="c1">// args for underlying layer (mqtt)</span>
        <span class="c1">// mqtt is as::basic_stream_socket&lt;as::ip::tcp, as::io_context::executor_type&gt;</span>
    <span class="p">);</span>
    <span class="c1">// handshake underlying layers</span>
    <span class="k">co_await</span> <span class="n">am</span><span class="o">::</span><span class="n">async_underlying_handshake</span><span class="p">(</span><span class="n">amcl</span><span class="p">.</span><span class="n">next_layer</span><span class="p">(),</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mqtts">mqtts</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">as</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ioc</span><span class="p">;</span>
    <span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">context</span> <span class="n">ctx</span><span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">tlsv12</span><span class="p">};</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">set_verify_mode</span><span class="p">(</span><span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">verify_none</span><span class="p">);</span>

    <span class="c1">// If you want to check server certificate, set cacert as follows.</span>
    <span class="c1">// ctx.load_verify_file(cacert);</span>

    <span class="c1">// You the broker requires additional TLS layer information,</span>
    <span class="c1">// you can use OpenSSL directly.</span>
    <span class="c1">//</span>
    <span class="c1">// static const unsigned char protos[5] = {4, 'm','q','t','t'};</span>
    <span class="c1">// auto res = SSL_CTX_set_alpn_protos(ctx.native_handle(), protos, 5);</span>
    <span class="c1">// // (check res)</span>

    <span class="n">am</span><span class="o">::</span><span class="n">client</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">protocol_version</span><span class="o">::</span><span class="n">v5</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">mqtts</span><span class="o">&gt;</span> <span class="n">amcl</span><span class="p">{</span>
        <span class="n">ioc</span><span class="p">.</span><span class="n">get_executor</span><span class="p">(),</span>  <span class="c1">// args for underlying layer (as::ssl::stream&lt;mqtt&gt;)</span>
        <span class="n">ctx</span>
    <span class="p">);</span>
    <span class="c1">// handshake underlying layers</span>
    <span class="k">co_await</span> <span class="n">am</span><span class="o">::</span><span class="n">async_underlying_handshake</span><span class="p">(</span><span class="n">amcl</span><span class="p">.</span><span class="n">next_layer</span><span class="p">(),</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ws">ws</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">as</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ioc</span><span class="p">;</span>
    <span class="n">am</span><span class="o">::</span><span class="n">client</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">protocol_version</span><span class="o">::</span><span class="n">v3_1_1</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">ws</span><span class="o">&gt;</span> <span class="n">amcl</span><span class="p">{</span>
    <span class="k">auto</span> <span class="n">amep</span> <span class="o">=</span> <span class="n">am</span><span class="o">::</span><span class="n">endpoint</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">role</span><span class="o">::</span><span class="n">client</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">ws</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">(</span>
        <span class="n">ioc</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()</span>  <span class="c1">// args for underlying layer (bs::websocket::stream&lt;mqtt&gt;)</span>
    <span class="p">);</span>
    <span class="c1">// handshake underlying layers</span>
    <span class="k">co_await</span> <span class="n">am</span><span class="o">::</span><span class="n">async_underlying_handshake</span><span class="p">(</span><span class="n">amcl</span><span class="p">.</span><span class="n">next_layer</span><span class="p">(),</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wss">wss</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">as</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ioc</span><span class="p">;</span>
    <span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">context</span> <span class="n">ctx</span><span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">tlsv12</span><span class="p">};</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">set_verify_mode</span><span class="p">(</span><span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">verify_none</span><span class="p">);</span>
    <span class="c1">// If you want to check server certificate, set cacert as follows.</span>
    <span class="c1">// ctx.load_verify_file(cacert);</span>

    <span class="c1">// You the broker requires additional TLS layer information,</span>
    <span class="c1">// you can use OpenSSL directly.</span>
    <span class="c1">//</span>
    <span class="c1">// static const unsigned char protos[5] = {4, 'm','q','t','t'};</span>
    <span class="c1">// auto res = SSL_CTX_set_alpn_protos(ctx.native_handle(), protos, 5);</span>
    <span class="c1">// // (check res)</span>

    <span class="n">am</span><span class="o">::</span><span class="n">client</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">protocol_version</span><span class="o">::</span><span class="n">v3_1_1</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">wss</span><span class="o">&gt;</span> <span class="n">amcl</span><span class="p">{</span>
        <span class="n">ioc</span><span class="p">.</span><span class="n">get_executor</span><span class="p">(),</span>  <span class="c1">// args for underlying layer ( bs::websocket::stream&lt;mqtts&gt;)</span>
        <span class="n">ctx</span>                  <span class="c1">// mqtts is as::ssl::stream&lt;mqtt&gt;</span>
    <span class="p">);</span>
    <span class="c1">// handshake underlying layers</span>
    <span class="k">co_await</span> <span class="n">am</span><span class="o">::</span><span class="n">async_underlying_handshake</span><span class="p">(</span><span class="n">amcl</span><span class="p">.</span><span class="n">next_layer</span><span class="p">(),</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_layer_access">Layer access</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Typically, you only need to <code>use next_layer()</code> to pass the <code>async_underlying_handshake()</code> argument. However, if you need to configure each layer individually, you can access all the underlying layers.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Layer access</th>
<th class="tableblock halign-left valign-top">mqtt</th>
<th class="tableblock halign-left valign-top">mqtts</th>
<th class="tableblock halign-left valign-top">ws</th>
<th class="tableblock halign-left valign-top">wss</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">next_layer()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLS stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">next_layer().next_layer()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLS stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">next_layer().next_layer().next_layer()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lowest_layer()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_send_mqtt_connect_packet_and_start_receive_loop">Send MQTT CONNECT packet and start receive loop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After the handshaking of the underlying layers is complete, initiate the MQTT layer connection.</p>
</div>
<div class="sect2">
<h3 id="_async_start_funtion"><a href="../api/classasync__mqtt_1_1client.html#a6808a6f7f9535ec152dcc9ee430caf92">async_start()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// prepare will message if you need.</span>
<span class="n">am</span><span class="o">::</span><span class="n">will</span> <span class="n">will</span><span class="p">{</span>
    <span class="s">"WillTopic1"</span><span class="p">,</span>
    <span class="s">"WillMessage1"</span><span class="p">,</span>
    <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_most_once</span><span class="p">,</span>
    <span class="p">{</span> <span class="c1">// properties</span>
        <span class="n">am</span><span class="o">::</span><span class="n">property</span><span class="o">::</span><span class="n">user_property</span><span class="p">{</span><span class="s">"key1"</span><span class="p">,</span> <span class="s">"val1"</span><span class="p">},</span>
        <span class="n">am</span><span class="o">::</span><span class="n">property</span><span class="o">::</span><span class="n">content_type</span><span class="p">{</span><span class="s">"text"</span><span class="p">},</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// MQTT connect and receive loop start</span>
<span class="k">auto</span> <span class="n">connack_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_start</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">connect_packet</span><span class="p">{</span>
        <span class="nb">true</span><span class="p">,</span>   <span class="c1">// clean_start</span>
        <span class="mh">0x1234</span><span class="p">,</span> <span class="c1">// keep_alive</span>
        <span class="s">"ClientIdentifier1"</span><span class="p">,</span>
        <span class="n">will</span><span class="p">,</span>   <span class="c1">// you can pass std::nullopt if you don't want to set the will message</span>
        <span class="s">"UserName1"</span><span class="p">,</span>
        <span class="s">"Password1"</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">connack_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">connack_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameters of <code>CompletionToken</code> are <code>error_code</code> and (optionally) <code>connack_packet</code>. The <code>connack_packet</code> will have a value only if <code>error_code</code> indicates success. When using <code>CompletionToken</code> with mechanisms like <code>as::use_awaitable</code>, <code>as::use_future</code>, or <code>as::deferred</code>, the initial <code>error_code</code> is converted into an exception. If you prefer to receive the <code>error_code</code> as a return value, you can proceed as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT connect and receive loop start</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">ec</span><span class="p">,</span> <span class="n">connack_opt</span><span class="p">]</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_start</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">connect_packet</span><span class="p">{</span>
        <span class="nb">true</span><span class="p">,</span>   <span class="c1">// clean_start</span>
        <span class="mh">0x1234</span><span class="p">,</span> <span class="c1">// keep_alive</span>
        <span class="s">"ClientIdentifier1"</span><span class="p">,</span>
        <span class="n">will</span><span class="p">,</span>   <span class="c1">// you can pass std::nullopt if you don't want to set the will message</span>
        <span class="s">"UserName1"</span><span class="p">,</span>
        <span class="s">"Password1"</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">as_tuple</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">connack_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">connack_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can omit explicit packet creation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">connack_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_start</span><span class="p">(</span>
    <span class="nb">true</span><span class="p">,</span>   <span class="c1">// clean_start</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">(</span><span class="mh">0x1234</span><span class="p">),</span> <span class="c1">// keep_alive</span>
    <span class="s">"ClientIdentifier1"</span><span class="p">,</span>
    <span class="n">will</span><span class="p">,</span>   <span class="c1">// you can pass std::nullopt if you don't want to set the will message</span>
    <span class="s">"UserName1"</span><span class="p">,</span>
    <span class="s">"Password1"</span><span class="p">,</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>connect_packet</code> correspondint to the client version is created automatically.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_send_subscribeunsubscribe_and_wait_subackunsuback">Send SUBSCRIBE/UNSUBSCRIBE and wait SUBACK/UNSUBACK</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_async_subscribe_funtion"><a href="../api/classasync__mqtt_1_1client.html#a10936f4e6d279d8fd869c6774f65dbaf">async_subscribe()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// subscribe</span>
<span class="c1">// MQTT send subscribe and wait suback</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">topic_subopts</span><span class="o">&gt;</span> <span class="n">sub_entry</span><span class="p">{</span>
    <span class="p">{</span><span class="s">"topic1"</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_most_once</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"topic2"</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_least_once</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"topic3"</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">exactly_once</span><span class="p">},</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="n">suback_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_subscribe</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">subscribe_packet</span><span class="p">{</span>
        <span class="o">*</span><span class="n">amcl</span><span class="p">.</span><span class="n">acquire_unique_packet_id</span><span class="p">(),</span> <span class="c1">// sync version only in thread safe environment</span>
        <span class="n">am</span><span class="o">::</span><span class="n">force_move</span><span class="p">(</span><span class="n">sub_entry</span><span class="p">)</span> <span class="c1">// sub_entry variable is required to avoid g++ bug</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">suback_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">suback_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameters of <code>CompletionToken</code> are <code>error_code</code> and an optional <code>suback_packet</code>. The <code>suback_packet</code> will have a value only if the <code>error_code</code> indicates success.</p>
</div>
</div>
<div class="sect2">
<h3 id="_async_unsubscribe_funtion"><a href="../api/classasync__mqtt_1_1client.html#a29e1d876f3ec12c7a8d69c406be15fc7">async_unsubscribe()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT send unsubscribe and wait unsuback</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">topic_sharename</span><span class="o">&gt;</span> <span class="n">unsub_entry</span><span class="p">{</span>
    <span class="s">"topic1"</span><span class="p">,</span>
    <span class="s">"topic2"</span><span class="p">,</span>
    <span class="s">"topic3"</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">unsuback_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_unsubscribe</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">unsubscribe_packet</span><span class="p">{</span>
        <span class="o">*</span><span class="n">amcl</span><span class="p">.</span><span class="n">acquire_unique_packet_id</span><span class="p">(),</span> <span class="c1">// sync version only in thread safe environment</span>
        <span class="n">am</span><span class="o">::</span><span class="n">force_move</span><span class="p">(</span><span class="n">unsub_entry</span><span class="p">)</span> <span class="c1">// unsub_entry variable is required to avoid g++ bug</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">unsuback_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">unsuback_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameters of <code>CompletionToken</code> are <code>error_code</code> and an optional <code>unsuback_packet</code>. The <code>unsuback_packet</code> will have a value only if the <code>error_code</code> indicates success.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_send_publish_packet_and_wait_response">Send PUBLISH packet and wait response</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_async_publish_funtion"><a href="../api/classasync__mqtt_1_1client.html#aea02e31d5f8e45f5eb7eb886f7a5068a">async_publish()</a> funtion</h3>
<div class="paragraph">
<p>Here is a code example that sending QoS0 PUBLISH packet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT publish QoS0 and wait response (socket write complete)</span>
<span class="k">auto</span> <span class="n">pubres0</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_publish</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">publish_packet</span><span class="p">{</span>
        <span class="s">"topic1"</span><span class="p">,</span>
        <span class="s">"payload1"</span><span class="p">,</span>
        <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_most_once</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameters of <code>CompletionToken</code> are <code>error_code</code> and <a href="../api/structasync__mqtt_1_1client_1_1pubres__t.html">pubres_t</a>. When you send a QoS0 PUBLISH packet, no response packet is expected, so the <code>CompletionToken</code> is invoked when the underlying layer&#8217;s <code>async_write</code> operation is finished. All members of <code>pubres_t</code> are <code>nullopt</code>.</p>
</div>
<div class="paragraph">
<p>Here is a code example that sending QoS1 PUBLISH packet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT publish QoS1 and wait response (puback receive)</span>
<span class="k">auto</span> <span class="n">pid_pub1_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_acquire_unique_packet_id</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span> <span class="c1">// async version</span>
<span class="k">auto</span> <span class="n">pubres1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_publish</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">publish_packet</span><span class="p">{</span>
        <span class="o">*</span><span class="n">pid_pub1_opt</span><span class="p">,</span>
        <span class="s">"topic2"</span><span class="p">,</span>
        <span class="s">"payload2"</span><span class="p">,</span>
        <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_least_once</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To create a QoS1 PUBLISH packet, you need to acquire a packet identifier. The example code above uses <a href="../api/classasync__mqtt_1_1client.html#ae866b887888316e02f14487ec2892a23">async_acquire_unique_packet_id()</a>, which is the asynchronous version. You can call it from anywhere you want. If all packet IDs are acquired, the <code>CompletionToken</code> parameter will be <code>nullopt</code>. For convenience, a synchronous version, <a href="../api/classasync__mqtt_1_1client.html#ab160ebb19bd7e51f8460e59a88deff86">acquire_unique_packet_id()</a>, also exists. The synchronous version must be called in a thread-safe context. For example, if you pass a strand-wrapped executor to the client upon creation, the callback handler of the asynchronous function will be in a thread-safe context.</p>
</div>
<div class="paragraph">
<p>After <code>async_publish()</code> completes, the <code>puback_opt</code> of <a href="../api/structasync__mqtt_1_1client_1_1pubres__t.html">pubres_t</a> is set. You can then retrieve the PUBACK packet.</p>
</div>
<div class="paragraph">
<p>Here is a code example that sending QoS1 PUBLISH packet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT publish QoS2 and wait response (pubrec, pubcomp receive)</span>
<span class="k">auto</span> <span class="n">pid_pub2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">acquire_unique_packet_id_wait_until</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span> <span class="c1">// async version</span>
<span class="k">auto</span> <span class="n">pubres2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_publish</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">publish_packet</span><span class="p">{</span>
        <span class="n">pid_pub2</span><span class="p">,</span>
        <span class="s">"topic3"</span><span class="p">,</span>
        <span class="s">"payload3"</span><span class="p">,</span>
        <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">exactly_once</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To create a QoS2 PUBLISH packet, you need to acquire a packet identifier. In this example, <a href="../api/classasync__mqtt_1_1client.html#a107f857b734a01cfeb6f8fc7894e60f1">async_acquire_unique_packet_id_wait_until()</a> is used. The <code>CompletionToken</code> parameter is a packet identifier that is not optional. If all packet identifiers are in use, the function waits until at least one packet identifier becomes available again and then invokes the <code>CompletionToken</code>. This helps keep the user code simple.</p>
</div>
<div class="paragraph">
<p>After <code>async_publish()</code> completes, the <code>pubrec_opt</code> and <code>pubcomp_opt</code> of <a href="../api/structasync__mqtt_1_1client_1_1pubres__t.html">pubres_t</a> are set. You can then retrieve the PUBREC and PUBCOMP packets.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_receive_publish_packet_from_the_broker">Receive PUBLISH packet from the broker</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_async_recv_funtion"><a href="../api/classasync__mqtt_1_1client.html#a825c14790ca009436f20c1b2c7952204">async_recv()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="p">[</span><span class="n">publish_opt</span><span class="p">,</span> <span class="n">disconnect_opt</span><span class="p">]</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_recv</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">publish_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">publish_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">disconnect_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">disconnect_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After you call the <code>async_start()</code> function, the received PUBLISH packets are stored in the client. You can retrieve them using the <code>async_recv()</code> function. If no packets are stored, <code>async_recv()</code> waits until a PUBLISH packet is received.</p>
</div>
<div class="paragraph">
<p>The parameters of <code>CompletionToken</code> are <code>error_code</code>, <code>publish_packet</code> (optional), and <code>disconnect_packet</code> (optional). <code>publish_packet</code> or <code>disconnect_packet</code> will have a value only if <code>error_code</code> indicates success.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_send_disconnect_packet">Send DISCONNECT packet</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_async_disconnect_funtion"><a href="../api/classasync__mqtt_1_1client.html#acd225df7e04770be801742bbbb437d9e">async_disconnect()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_disconnect</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">disconnect_packet</span><span class="p">{},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CompletionToken</code> parameter is <code>error_code</code>.</p>
</div>
<div class="paragraph">
<p>Sending a DISCONNECT packet to the broker initiates a graceful disconnect sequence. The broker sends the MQTT will message if needed, then disconnects the network connection from its side. The client detects the disconnection and finally closes the client-side socket.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_close">Close</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_async_close_funtion"><a href="../api/classasync__mqtt_1_1client.html#a9dda4bdcebd220beb5392adb5da86110">async_close()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">async_close</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CompletionToken</code> parameter is nothing.</p>
</div>
<div class="paragraph">
<p>If you want to close the socket forcibly, you can call the <code>async_close()</code> function. This is useful, for example, when no packets are received from the broker unexpectedly and the client side doesn&#8217;t detect the disconnection.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whole_code">Whole code</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/redboltz/async_mqtt/blob/6.0.0/example/cl_cpp20coro_mqtt.cpp">cl_cpp20coro_mqtt.cpp</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_supported_functionality">Supported Functionality</h2>
<div class="sectionbody">
<div class="paragraph">
<p>client supports the following functionalities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../functionality/connect_timeout.html">Connect Timeout</a></p>
</li>
<li>
<p><a href="../functionality/keep_session.html">Keep Session</a></p>
</li>
<li>
<p><a href="../functionality/topic_alias.html">Topic Alias</a></p>
</li>
<li>
<p><a href="../functionality/request_response.html">Request Response</a></p>
</li>
<li>
<p><a href="../functionality/receive_maximum.html">Receive Maximum</a></p>
</li>
<li>
<p><a href="../functionality/maximum_packet_size.html">Maximum Packet Size</a></p>
</li>
<li>
<p><a href="../logging.html">Logging</a></p>
</li>
</ul>
</div>
<div id="navigation">
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-middle"><a href="../trial.html">Prev</a></th>
<th class="tableblock halign-center valign-middle"><a href="../index.html">Up</a><br>
<a href="../index.html">Home</a></th>
<th class="tableblock halign-right valign-middle"><a href="create_endpoint.html">Next</a></th>
</tr>
</thead>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>