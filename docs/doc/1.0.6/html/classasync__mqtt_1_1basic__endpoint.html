<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>async_mqtt: async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">async_mqtt<span id="projectnumber">&#160;1.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>async_mqtt</b></li><li class="navelem"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classasync__mqtt_1_1basic__endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>MQTT endpoint corresponding to the connection.  
 <a href="classasync__mqtt_1_1basic__endpoint.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a045005fba8b583a870cde28a58da70bb"><td class="memItemLeft" align="right" valign="top"><a id="a045005fba8b583a870cde28a58da70bb" name="a045005fba8b583a870cde28a58da70bb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>next_layer_type</b> = NextLayer</td></tr>
<tr class="memdesc:a045005fba8b583a870cde28a58da70bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type given as NextLayer. <br /></td></tr>
<tr class="separator:a045005fba8b583a870cde28a58da70bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842403c46cb455e467380f28d3a14289"><td class="memItemLeft" align="right" valign="top"><a id="a842403c46cb455e467380f28d3a14289" name="a842403c46cb455e467380f28d3a14289"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>strand_type</b> = typename stream_type::strand_type</td></tr>
<tr class="memdesc:a842403c46cb455e467380f28d3a14289"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of stand that is used MQTT stream exclusive control. <br /></td></tr>
<tr class="separator:a842403c46cb455e467380f28d3a14289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5098e22b58adbee93e452ede78ab1adc"><td class="memItemLeft" align="right" valign="top"><a id="a5098e22b58adbee93e452ede78ab1adc" name="a5098e22b58adbee93e452ede78ab1adc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>packet_variant_type</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">basic_packet_variant</a>&lt; PacketIdBytes &gt;</td></tr>
<tr class="memdesc:a5098e22b58adbee93e452ede78ab1adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of packet_variant. <br /></td></tr>
<tr class="separator:a5098e22b58adbee93e452ede78ab1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc1a9fe62d017b44fcc94a7fd9ab090"><td class="memItemLeft" align="right" valign="top"><a id="a5fc1a9fe62d017b44fcc94a7fd9ab090" name="a5fc1a9fe62d017b44fcc94a7fd9ab090"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>packet_id_t</b> = typename packet_id_type&lt; PacketIdBytes &gt;::type</td></tr>
<tr class="memdesc:a5fc1a9fe62d017b44fcc94a7fd9ab090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of MQTT Packet Identifier. <br /></td></tr>
<tr class="separator:a5fc1a9fe62d017b44fcc94a7fd9ab090"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc8fe2d40a34da40817c6624a086dc25"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abc8fe2d40a34da40817c6624a086dc25"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#abc8fe2d40a34da40817c6624a086dc25">basic_endpoint</a> (<a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a> ver, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abc8fe2d40a34da40817c6624a086dc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <br /></td></tr>
<tr class="separator:abc8fe2d40a34da40817c6624a086dc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4ac8feefc66e49003a30c710695e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a842403c46cb455e467380f28d3a14289">strand_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a3f4ac8feefc66e49003a30c710695e73">strand</a> () const</td></tr>
<tr class="memdesc:a3f4ac8feefc66e49003a30c710695e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">strand getter  <br /></td></tr>
<tr class="separator:a3f4ac8feefc66e49003a30c710695e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b578d516addd0e490160d4189dd7b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a842403c46cb455e467380f28d3a14289">strand_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ac6b578d516addd0e490160d4189dd7b9">strand</a> ()</td></tr>
<tr class="memdesc:ac6b578d516addd0e490160d4189dd7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">strand getter  <br /></td></tr>
<tr class="separator:ac6b578d516addd0e490160d4189dd7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a045005fba8b583a870cde28a58da70bb">next_layer_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ada60e5d8c35b1d668a4edf5d0c332f0b">next_layer</a> () const</td></tr>
<tr class="memdesc:ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_layer getter  <br /></td></tr>
<tr class="separator:ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc21bc830ae4ffd4a7803d3bdd166a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a045005fba8b583a870cde28a58da70bb">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#acc21bc830ae4ffd4a7803d3bdd166a21">next_layer</a> ()</td></tr>
<tr class="memdesc:acc21bc830ae4ffd4a7803d3bdd166a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_layer getter  <br /></td></tr>
<tr class="separator:acc21bc830ae4ffd4a7803d3bdd166a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac421785ffce061dc7792a22b586806e4"><td class="memItemLeft" align="right" valign="top">auto const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ac421785ffce061dc7792a22b586806e4">lowest_layer</a> () const</td></tr>
<tr class="memdesc:ac421785ffce061dc7792a22b586806e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer getter  <br /></td></tr>
<tr class="separator:ac421785ffce061dc7792a22b586806e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f483895a76b9d399ab15c32fc201f81"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a8f483895a76b9d399ab15c32fc201f81">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a8f483895a76b9d399ab15c32fc201f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer getter  <br /></td></tr>
<tr class="separator:a8f483895a76b9d399ab15c32fc201f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8920d50890684fc33eab70c709a90f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5e8920d50890684fc33eab70c709a90f">set_auto_pub_response</a> (bool val)</td></tr>
<tr class="memdesc:a5e8920d50890684fc33eab70c709a90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto publish response setter. Should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call.  <br /></td></tr>
<tr class="separator:a5e8920d50890684fc33eab70c709a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e77ec0b180801e25279d35d225a7771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5e77ec0b180801e25279d35d225a7771">set_auto_ping_response</a> (bool val)</td></tr>
<tr class="memdesc:a5e77ec0b180801e25279d35d225a7771"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto pingreq response setter. Should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call.  <br /></td></tr>
<tr class="separator:a5e77ec0b180801e25279d35d225a7771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596d2617fa46cd0f37b40afbf4f912df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a596d2617fa46cd0f37b40afbf4f912df">set_auto_map_topic_alias_send</a> (bool val)</td></tr>
<tr class="memdesc:a596d2617fa46cd0f37b40afbf4f912df"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto map (allocate) topic alias on send PUBLISH packet. If all topic aliases are used, then overwrite by LRU algorithm. <br  />
 This function should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:a596d2617fa46cd0f37b40afbf4f912df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f40da2602fb6b22049aafa815782e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a70f40da2602fb6b22049aafa815782e0">set_auto_replace_topic_alias_send</a> (bool val)</td></tr>
<tr class="memdesc:a70f40da2602fb6b22049aafa815782e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto replace topic with corresponding topic alias on send PUBLISH packet. Registering topic alias need to do manually. <br  />
 This function should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:a70f40da2602fb6b22049aafa815782e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0379f9c13e189e2847c9908cf05856ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a0379f9c13e189e2847c9908cf05856ec">set_ping_resp_recv_timeout_ms</a> (std::size_t ms)</td></tr>
<tr class="memdesc:a0379f9c13e189e2847c9908cf05856ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeout for receiving PINGRESP packet after PINGREQ packet is sent. If the timer is fired, then the underlying layer is closed from the client side. If the protocol_version is v5, then send DISCONNECT packet with the reason code disconnect_reason_code::keep_alive_timeout automatically before underlying layer is closed. <br  />
 This function should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:a0379f9c13e189e2847c9908cf05856ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c5e674d28854efa852129ddcb83625"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a24c5e674d28854efa852129ddcb83625"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(optional&lt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt;)&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a24c5e674d28854efa852129ddcb83625">acquire_unique_packet_id</a> (CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a24c5e674d28854efa852129ddcb83625"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id.  <br /></td></tr>
<tr class="separator:a24c5e674d28854efa852129ddcb83625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9145d84663d38743fb47cf2d9f124b"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a6d9145d84663d38743fb47cf2d9f124b"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(bool)&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a6d9145d84663d38743fb47cf2d9f124b">register_packet_id</a> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> packet_id, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a6d9145d84663d38743fb47cf2d9f124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">register packet_id.  <br /></td></tr>
<tr class="separator:a6d9145d84663d38743fb47cf2d9f124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4296e338bc6847e59ff64fd5aa16a25"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:ad4296e338bc6847e59ff64fd5aa16a25"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void()&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ad4296e338bc6847e59ff64fd5aa16a25">release_packet_id</a> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> packet_id, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:ad4296e338bc6847e59ff64fd5aa16a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">release packet_id.  <br /></td></tr>
<tr class="separator:ad4296e338bc6847e59ff64fd5aa16a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadb5049b6fba3dd8075ba4f8daadcd0"><td class="memTemplParams" colspan="2">template&lt;typename Packet , typename CompletionToken &gt; </td></tr>
<tr class="memitem:aeadb5049b6fba3dd8075ba4f8daadcd0"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(<a class="el" href="structasync__mqtt_1_1system__error.html">system_error</a>)&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0">send</a> (Packet packet, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:aeadb5049b6fba3dd8075ba4f8daadcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">send packet users can call <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> before the previous <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>'s CompletionToken is invoked  <br /></td></tr>
<tr class="separator:aeadb5049b6fba3dd8075ba4f8daadcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43f3f6c57a9e9267409132de7e44f25"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:ae43f3f6c57a9e9267409132de7e44f25"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5098e22b58adbee93e452ede78ab1adc">packet_variant_type</a>)&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25">recv</a> (CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:ae43f3f6c57a9e9267409132de7e44f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked  <br /></td></tr>
<tr class="separator:ae43f3f6c57a9e9267409132de7e44f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0e5b8a19c9f9fde23077504a205480"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a8b0e5b8a19c9f9fde23077504a205480"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5098e22b58adbee93e452ede78ab1adc">packet_variant_type</a>)&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a8b0e5b8a19c9f9fde23077504a205480">recv</a> (std::set&lt; control_packet_type &gt; types, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a8b0e5b8a19c9f9fde23077504a205480"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked.  <br /></td></tr>
<tr class="separator:a8b0e5b8a19c9f9fde23077504a205480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1f136a75fbe2ffb2dac8e1b5a52094"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:afa1f136a75fbe2ffb2dac8e1b5a52094"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5098e22b58adbee93e452ede78ab1adc">packet_variant_type</a>)&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#afa1f136a75fbe2ffb2dac8e1b5a52094">recv</a> (<a class="el" href="endpoint_8hpp.html#aed6ebca93cac28c67f2b4fb8641e775a">filter</a> fil, std::set&lt; control_packet_type &gt; types, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:afa1f136a75fbe2ffb2dac8e1b5a52094"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. @params fil if <code>match</code> then matched types are targets. if <code>except</code> then not matched types are targets.  <br /></td></tr>
<tr class="separator:afa1f136a75fbe2ffb2dac8e1b5a52094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ea2597adf88429dd8abaadc0d9c024"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a58ea2597adf88429dd8abaadc0d9c024"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void()&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a58ea2597adf88429dd8abaadc0d9c024">close</a> (CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a58ea2597adf88429dd8abaadc0d9c024"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the underlying connection  <br /></td></tr>
<tr class="separator:a58ea2597adf88429dd8abaadc0d9c024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb51449a3077b44cc3d56a1ecf9edcb0"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:abb51449a3077b44cc3d56a1ecf9edcb0"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void()&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#abb51449a3077b44cc3d56a1ecf9edcb0">restore_packets</a> (std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt; pvs, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:abb51449a3077b44cc3d56a1ecf9edcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore packets the restored packets would automatically send when CONNACK packet is received  <br /></td></tr>
<tr class="separator:abb51449a3077b44cc3d56a1ecf9edcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8b85838eb7a05202b3a0f7e7521961"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a0f8b85838eb7a05202b3a0f7e7521961"><td class="memTemplItemLeft" align="right" valign="top">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt;)&gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a0f8b85838eb7a05202b3a0f7e7521961">get_stored_packets</a> (CompletionToken &amp;&amp;token) const</td></tr>
<tr class="memdesc:a0f8b85838eb7a05202b3a0f7e7521961"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stored packets sotred packets mean inflight packets.  <br /></td></tr>
<tr class="separator:a0f8b85838eb7a05202b3a0f7e7521961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d58c77fd13b77afdbc94a6e3c865b36"><td class="memItemLeft" align="right" valign="top">optional&lt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a7d58c77fd13b77afdbc94a6e3c865b36">acquire_unique_packet_id</a> ()</td></tr>
<tr class="memdesc:a7d58c77fd13b77afdbc94a6e3c865b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id.  <br /></td></tr>
<tr class="separator:a7d58c77fd13b77afdbc94a6e3c865b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91683e5aa2ed234e5c14f79361ff2deb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a91683e5aa2ed234e5c14f79361ff2deb">register_packet_id</a> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> pid)</td></tr>
<tr class="memdesc:a91683e5aa2ed234e5c14f79361ff2deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">register packet_id.  <br /></td></tr>
<tr class="separator:a91683e5aa2ed234e5c14f79361ff2deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90777e5fde27013cc8d308d501a6ead8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a90777e5fde27013cc8d308d501a6ead8">release_packet_id</a> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> pid)</td></tr>
<tr class="memdesc:a90777e5fde27013cc8d308d501a6ead8"><td class="mdescLeft">&#160;</td><td class="mdescRight">release packet_id.  <br /></td></tr>
<tr class="separator:a90777e5fde27013cc8d308d501a6ead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaf7274ef58eadf15428071cae9e894"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a1aaf7274ef58eadf15428071cae9e894">get_qos2_publish_handled_pids</a> () const</td></tr>
<tr class="memdesc:a1aaf7274ef58eadf15428071cae9e894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get processed but not released QoS2 packet ids This function should be called after disconnection.  <br /></td></tr>
<tr class="separator:a1aaf7274ef58eadf15428071cae9e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4696744f07068176e48e12aeb4998fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a4696744f07068176e48e12aeb4998fb0">restore_qos2_publish_handled_pids</a> (std::set&lt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt; pids)</td></tr>
<tr class="memdesc:a4696744f07068176e48e12aeb4998fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore processed but not released QoS2 packet ids This function should be called before receive the first publish.  <br /></td></tr>
<tr class="separator:a4696744f07068176e48e12aeb4998fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a6dfe47bd9ab1590e66f110e3dbe1087e">restore_packets</a> (std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt; pvs)</td></tr>
<tr class="memdesc:a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore packets the restored packets would automatically send when CONNACK packet is received  <br /></td></tr>
<tr class="separator:a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5ed8d45ffcfb114533d8de5ddddb4f92">get_stored_packets</a> () const</td></tr>
<tr class="memdesc:a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stored packets sotred packets mean inflight packets.  <br /></td></tr>
<tr class="separator:a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a9cbabd5f427b1cb18d61ac49c7bbf83b">get_protocol_version</a> () const</td></tr>
<tr class="memdesc:a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MQTT protocol version  <br /></td></tr>
<tr class="separator:a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23794d3c9fe9385a10a76ca58e9b00c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae23794d3c9fe9385a10a76ca58e9b00c">is_publish_processing</a> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> pid) const</td></tr>
<tr class="memdesc:ae23794d3c9fe9385a10a76ca58e9b00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MQTT PUBLISH packet processing status .  <br /></td></tr>
<tr class="separator:ae23794d3c9fe9385a10a76ca58e9b00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae37385dccb86c73c3fa61e1f7eec5e23"><td class="memItemLeft" align="right" valign="top"><a id="ae37385dccb86c73c3fa61e1f7eec5e23" name="ae37385dccb86c73c3fa61e1f7eec5e23"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>packet_id_bytes</b> = PacketIdBytes</td></tr>
<tr class="memdesc:ae37385dccb86c73c3fa61e1f7eec5e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value given as PacketIdBytes. <br /></td></tr>
<tr class="separator:ae37385dccb86c73c3fa61e1f7eec5e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a2e1a75540d6fe007c2a768600ad6d8cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, typename NextLayer &gt; </td></tr>
<tr class="memitem:a2e1a75540d6fe007c2a768600ad6d8cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a2e1a75540d6fe007c2a768600ad6d8cb">endpoint</a> = <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt; Role, 2, NextLayer &gt;</td></tr>
<tr class="memdesc:a2e1a75540d6fe007c2a768600ad6d8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2).  <br /></td></tr>
<tr class="separator:a2e1a75540d6fe007c2a768600ad6d8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer&gt;<br />
class async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt;</div><p>MQTT endpoint corresponding to the connection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Role</td><td>role for packet sendable checking </td></tr>
    <tr><td class="paramname">PacketIdBytes</td><td>MQTT spec is 2. You can use <code>endpoint</code> for that. </td></tr>
    <tr><td class="paramname">NextLayer</td><td>Just next layer for <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. mqtt, mqtts, ws, and wss are predefined. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abc8fe2d40a34da40817c6624a086dc25" name="abc8fe2d40a34da40817c6624a086dc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8fe2d40a34da40817c6624a086dc25">&#9670;&#160;</a></span>basic_endpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::basic_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a>&#160;</td>
          <td class="paramname"><em>ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types for the next layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ver</td><td>MQTT protocol version (v5 or v3_1_1) </td></tr>
    <tr><td class="paramname">args</td><td>args for the next layer. There are predefined next layer types: <br  />
 <a class="el" href="predefined__underlying__layer_8hpp.html#a27f859f34b0db17135add24d84eef9e0">protocol::mqtt</a>, <a class="el" href="predefined__underlying__layer_8hpp.html#aa8e118fcdb4eb5d0cca58615282b4146">protocol::mqtts</a>, <a class="el" href="predefined__underlying__layer_8hpp.html#a4926c44b7cc4725e9516c14c9f4d8fcd">protocol::ws</a>, and <a class="el" href="predefined__underlying__layer_8hpp.html#a74219d816d3e7d2cf80c5ce6cdc4cb29">protocol::wss</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7d58c77fd13b77afdbc94a6e3c865b36" name="a7d58c77fd13b77afdbc94a6e3c865b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d58c77fd13b77afdbc94a6e3c865b36">&#9670;&#160;</a></span>acquire_unique_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>acuire unique packet_id. </p>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;packet_id_t&gt; if acquired return acquired packet id, otherwise nullopt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a24c5e674d28854efa852129ddcb83625" name="a24c5e674d28854efa852129ddcb83625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c5e674d28854efa852129ddcb83625">&#9670;&#160;</a></span>acquire_unique_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(optional&lt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt;)&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>acuire unique packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is optional&lt;packet_id_t&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a58ea2597adf88429dd8abaadc0d9c024" name="a58ea2597adf88429dd8abaadc0d9c024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ea2597adf88429dd8abaadc0d9c024">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void()&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::close </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>close the underlying connection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a9cbabd5f427b1cb18d61ac49c7bbf83b" name="a9cbabd5f427b1cb18d61ac49c7bbf83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbabd5f427b1cb18d61ac49c7bbf83b">&#9670;&#160;</a></span>get_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::get_protocol_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get MQTT protocol version </p>
<dl class="section return"><dt>Returns</dt><dd>MQTT protocol version </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a1aaf7274ef58eadf15428071cae9e894" name="a1aaf7274ef58eadf15428071cae9e894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaf7274ef58eadf15428071cae9e894">&#9670;&#160;</a></span>get_qos2_publish_handled_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::get_qos2_publish_handled_pids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get processed but not released QoS2 packet ids This function should be called after disconnection. </p>
<dl class="section return"><dt>Returns</dt><dd>set of packet_ids </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a5ed8d45ffcfb114533d8de5ddddb4f92" name="a5ed8d45ffcfb114533d8de5ddddb4f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed8d45ffcfb114533d8de5ddddb4f92">&#9670;&#160;</a></span>get_stored_packets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::get_stored_packets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get stored packets sotred packets mean inflight packets. </p>
<ul>
<li>PUBLISH packet (QoS1) not received PUBACK packet</li>
<li>PUBLISH packet (QoS1) not received PUBREC packet</li>
<li>PUBREL packet not received PUBCOMP packet <dl class="section return"><dt>Returns</dt><dd>std::vector&lt;basic_store_packet_variant&lt;PacketIdBytes&gt;&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a0f8b85838eb7a05202b3a0f7e7521961" name="a0f8b85838eb7a05202b3a0f7e7521961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8b85838eb7a05202b3a0f7e7521961">&#9670;&#160;</a></span>get_stored_packets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt;)&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::get_stored_packets </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get stored packets sotred packets mean inflight packets. </p>
<ul>
<li>PUBLISH packet (QoS1) not received PUBACK packet</li>
<li>PUBLISH packet (QoS1) not received PUBREC packet</li>
<li>PUBREL packet not received PUBCOMP packet <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is std::vector&lt;basic_store_packet_variant&lt;PacketIdBytes&gt;&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae23794d3c9fe9385a10a76ca58e9b00c" name="ae23794d3c9fe9385a10a76ca58e9b00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23794d3c9fe9385a10a76ca58e9b00c">&#9670;&#160;</a></span>is_publish_processing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::is_publish_processing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get MQTT PUBLISH packet processing status . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>packet_id corresponding to the publish packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the packet is processing, then true, otherwise false. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a8f483895a76b9d399ab15c32fc201f81" name="a8f483895a76b9d399ab15c32fc201f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f483895a76b9d399ab15c32fc201f81">&#9670;&#160;</a></span>lowest_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lowest_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the lowest_layer </dd></dl>

</div>
</div>
<a id="ac421785ffce061dc7792a22b586806e4" name="ac421785ffce061dc7792a22b586806e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac421785ffce061dc7792a22b586806e4">&#9670;&#160;</a></span>lowest_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto const  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lowest_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the lowest_layer </dd></dl>

</div>
</div>
<a id="acc21bc830ae4ffd4a7803d3bdd166a21" name="acc21bc830ae4ffd4a7803d3bdd166a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc21bc830ae4ffd4a7803d3bdd166a21">&#9670;&#160;</a></span>next_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a045005fba8b583a870cde28a58da70bb">next_layer_type</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the next_layer </dd></dl>

</div>
</div>
<a id="ada60e5d8c35b1d668a4edf5d0c332f0b" name="ada60e5d8c35b1d668a4edf5d0c332f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada60e5d8c35b1d668a4edf5d0c332f0b">&#9670;&#160;</a></span>next_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a045005fba8b583a870cde28a58da70bb">next_layer_type</a> const  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the next_layer </dd></dl>

</div>
</div>
<a id="ae43f3f6c57a9e9267409132de7e44f25" name="ae43f3f6c57a9e9267409132de7e44f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43f3f6c57a9e9267409132de7e44f25">&#9670;&#160;</a></span>recv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5098e22b58adbee93e452ede78ab1adc">packet_variant_type</a>)&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="afa1f136a75fbe2ffb2dac8e1b5a52094" name="afa1f136a75fbe2ffb2dac8e1b5a52094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1f136a75fbe2ffb2dac8e1b5a52094">&#9670;&#160;</a></span>recv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5098e22b58adbee93e452ede78ab1adc">packet_variant_type</a>)&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#aed6ebca93cac28c67f2b4fb8641e775a">filter</a>&#160;</td>
          <td class="paramname"><em>fil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; control_packet_type &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. @params fil if <code>match</code> then matched types are targets. if <code>except</code> then not matched types are targets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>target control_packet_types </td></tr>
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a8b0e5b8a19c9f9fde23077504a205480" name="a8b0e5b8a19c9f9fde23077504a205480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0e5b8a19c9f9fde23077504a205480">&#9670;&#160;</a></span>recv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(<a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5098e22b58adbee93e452ede78ab1adc">packet_variant_type</a>)&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; control_packet_type &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#ae43f3f6c57a9e9267409132de7e44f25" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>target control_packet_types </td></tr>
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a6d9145d84663d38743fb47cf2d9f124b" name="a6d9145d84663d38743fb47cf2d9f124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9145d84663d38743fb47cf2d9f124b">&#9670;&#160;</a></span>register_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(bool)&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to register </td></tr>
    <tr><td class="paramname">token</td><td>the param is bool. If true, success, otherwise the packet_id has already been used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a91683e5aa2ed234e5c14f79361ff2deb" name="a91683e5aa2ed234e5c14f79361ff2deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91683e5aa2ed234e5c14f79361ff2deb">&#9670;&#160;</a></span>register_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If true, success, otherwise the packet_id has already been used. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="ad4296e338bc6847e59ff64fd5aa16a25" name="ad4296e338bc6847e59ff64fd5aa16a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4296e338bc6847e59ff64fd5aa16a25">&#9670;&#160;</a></span>release_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void()&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to release </td></tr>
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a90777e5fde27013cc8d308d501a6ead8" name="a90777e5fde27013cc8d308d501a6ead8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90777e5fde27013cc8d308d501a6ead8">&#9670;&#160;</a></span>release_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to release </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a6dfe47bd9ab1590e66f110e3dbe1087e" name="a6dfe47bd9ab1590e66f110e3dbe1087e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfe47bd9ab1590e66f110e3dbe1087e">&#9670;&#160;</a></span>restore_packets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::restore_packets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt;&#160;</td>
          <td class="paramname"><em>pvs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>restore packets the restored packets would automatically send when CONNACK packet is received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvs</td><td>packets to restore </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="abb51449a3077b44cc3d56a1ecf9edcb0" name="abb51449a3077b44cc3d56a1ecf9edcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb51449a3077b44cc3d56a1ecf9edcb0">&#9670;&#160;</a></span>restore_packets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void()&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::restore_packets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt;&#160;</td>
          <td class="paramname"><em>pvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>restore packets the restored packets would automatically send when CONNACK packet is received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvs</td><td>packets to restore </td></tr>
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a4696744f07068176e48e12aeb4998fb0" name="a4696744f07068176e48e12aeb4998fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4696744f07068176e48e12aeb4998fb0">&#9670;&#160;</a></span>restore_qos2_publish_handled_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::restore_qos2_publish_handled_pids </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt;&#160;</td>
          <td class="paramname"><em>pids</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore processed but not released QoS2 packet ids This function should be called before receive the first publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pids</td><td>packet ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="aeadb5049b6fba3dd8075ba4f8daadcd0" name="aeadb5049b6fba3dd8075ba4f8daadcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadb5049b6fba3dd8075ba4f8daadcd0">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename Packet , typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">as::async_result&lt; std::decay_t&lt; CompletionToken &gt;, void(<a class="el" href="structasync__mqtt_1_1system__error.html">system_error</a>)&gt;::return_type <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::send </td>
          <td>(</td>
          <td class="paramtype">Packet&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send packet users can call <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> before the previous <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>'s CompletionToken is invoked </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>packet to send </td></tr>
    <tr><td class="paramname">token</td><td>the param is <a class="el" href="structasync__mqtt_1_1system__error.html" title="async_mqtt error class. It is used as CompletionToken parameter and exception.">system_error</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a596d2617fa46cd0f37b40afbf4f912df" name="a596d2617fa46cd0f37b40afbf4f912df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596d2617fa46cd0f37b40afbf4f912df">&#9670;&#160;</a></span>set_auto_map_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_auto_map_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto map (allocate) topic alias on send PUBLISH packet. If all topic aliases are used, then overwrite by LRU algorithm. <br  />
 This function should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically mapping. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable auto mapping, otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e77ec0b180801e25279d35d225a7771" name="a5e77ec0b180801e25279d35d225a7771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e77ec0b180801e25279d35d225a7771">&#9670;&#160;</a></span>set_auto_ping_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_auto_ping_response </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto pingreq response setter. Should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically sending. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, puback, pubrec, pubrel, and pubcomp are automatically sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e8920d50890684fc33eab70c709a90f" name="a5e8920d50890684fc33eab70c709a90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8920d50890684fc33eab70c709a90f">&#9670;&#160;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto publish response setter. Should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically sending. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, puback, pubrec, pubrel, and pubcomp are automatically sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f40da2602fb6b22049aafa815782e0" name="a70f40da2602fb6b22049aafa815782e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f40da2602fb6b22049aafa815782e0">&#9670;&#160;</a></span>set_auto_replace_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_auto_replace_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto replace topic with corresponding topic alias on send PUBLISH packet. Registering topic alias need to do manually. <br  />
 This function should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically replacing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable auto replacing, otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0379f9c13e189e2847c9908cf05856ec" name="a0379f9c13e189e2847c9908cf05856ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0379f9c13e189e2847c9908cf05856ec">&#9670;&#160;</a></span>set_ping_resp_recv_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_ping_resp_recv_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set timeout for receiving PINGRESP packet after PINGREQ packet is sent. If the timer is fired, then the underlying layer is closed from the client side. If the protocol_version is v5, then send DISCONNECT packet with the reason code disconnect_reason_code::keep_alive_timeout automatically before underlying layer is closed. <br  />
 This function should be called before <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#aeadb5049b6fba3dd8075ba4f8daadcd0" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default timeout is not set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if 0, timer is not set, otherwise set val milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b578d516addd0e490160d4189dd7b9" name="ac6b578d516addd0e490160d4189dd7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b578d516addd0e490160d4189dd7b9">&#9670;&#160;</a></span>strand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a842403c46cb455e467380f28d3a14289">strand_type</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::strand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>strand getter </p>
<dl class="section return"><dt>Returns</dt><dd>eference of the strand </dd></dl>

</div>
</div>
<a id="a3f4ac8feefc66e49003a30c710695e73" name="a3f4ac8feefc66e49003a30c710695e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4ac8feefc66e49003a30c710695e73">&#9670;&#160;</a></span>strand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a842403c46cb455e467380f28d3a14289">strand_type</a> const  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::strand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>strand getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the strand </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a2e1a75540d6fe007c2a768600ad6d8cb" name="a2e1a75540d6fe007c2a768600ad6d8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1a75540d6fe007c2a768600ad6d8cb">&#9670;&#160;</a></span>endpoint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, typename NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classasync__mqtt_1_1basic__endpoint.html#a2e1a75540d6fe007c2a768600ad6d8cb">endpoint</a> =  <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt;Role, 2, NextLayer&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Role</td><td>role for packet sendable checking </td></tr>
    <tr><td class="paramname">NextLayer</td><td>Just next layer for <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. mqtt, mqtts, ws, and wss are predefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/async_mqtt/include/async_mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
