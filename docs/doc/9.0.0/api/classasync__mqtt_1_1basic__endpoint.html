<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>async_mqtt: async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">async_mqtt<span id="projectnumber">&#160;9.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classasync__mqtt_1_1basic__endpoint.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classasync__mqtt_1_1basic__endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__connection.html">MQTT connection</a> &raquo; <a class="el" href="group__endpoint.html">endpoint (Packet level MQTT endpoint for client/server,broker)</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>MQTT endpoint corresponding to the connection.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__mqtt_1_1basic__endpoint_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">rebinds the <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> type to another executor  <a href="structasync__mqtt_1_1basic__endpoint_1_1rebind__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af485b15270d8b1e12746342d4f79cb15" id="r_af485b15270d8b1e12746342d4f79cb15"><td class="memItemLeft" align="right" valign="top"><a id="af485b15270d8b1e12746342d4f79cb15" name="af485b15270d8b1e12746342d4f79cb15"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>next_layer_type</b> = typename stream_type::next_layer_type</td></tr>
<tr class="memdesc:af485b15270d8b1e12746342d4f79cb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the given NextLayer <br /></td></tr>
<tr class="separator:af485b15270d8b1e12746342d4f79cb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d52c82d975d51c9f08627abbf8dec7" id="r_ac6d52c82d975d51c9f08627abbf8dec7"><td class="memItemLeft" align="right" valign="top"><a id="ac6d52c82d975d51c9f08627abbf8dec7" name="ac6d52c82d975d51c9f08627abbf8dec7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>lowest_layer_type</b> = typename stream_type::lowest_layer_type</td></tr>
<tr class="memdesc:ac6d52c82d975d51c9f08627abbf8dec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer_type of the given NextLayer <br /></td></tr>
<tr class="separator:ac6d52c82d975d51c9f08627abbf8dec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631e1e2d54cfc10767b1d8c29639441d" id="r_a631e1e2d54cfc10767b1d8c29639441d"><td class="memItemLeft" align="right" valign="top"><a id="a631e1e2d54cfc10767b1d8c29639441d" name="a631e1e2d54cfc10767b1d8c29639441d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>executor_type</b> = typename next_layer_type::executor_type</td></tr>
<tr class="memdesc:a631e1e2d54cfc10767b1d8c29639441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">executor_type of the given NextLayer <br /></td></tr>
<tr class="separator:a631e1e2d54cfc10767b1d8c29639441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5098e22b58adbee93e452ede78ab1adc" id="r_a5098e22b58adbee93e452ede78ab1adc"><td class="memItemLeft" align="right" valign="top"><a id="a5098e22b58adbee93e452ede78ab1adc" name="a5098e22b58adbee93e452ede78ab1adc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>packet_variant_type</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">basic_packet_variant</a>&lt;PacketIdBytes&gt;</td></tr>
<tr class="memdesc:a5098e22b58adbee93e452ede78ab1adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of packet_variant. <br /></td></tr>
<tr class="separator:a5098e22b58adbee93e452ede78ab1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc8fe2d40a34da40817c6624a086dc25" id="r_abc8fe2d40a34da40817c6624a086dc25"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abc8fe2d40a34da40817c6624a086dc25"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc8fe2d40a34da40817c6624a086dc25">basic_endpoint</a> (<a class="el" href="group__mqtt.html#ga133d6d106d4e527d07fea2d12544c0c0">protocol_version</a> ver, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abc8fe2d40a34da40817c6624a086dc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <br /></td></tr>
<tr class="separator:abc8fe2d40a34da40817c6624a086dc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1d46688d3a6ed1d20e3669cb5aefc2" id="r_a1e1d46688d3a6ed1d20e3669cb5aefc2"><td class="memItemLeft" align="right" valign="top"><a id="a1e1d46688d3a6ed1d20e3669cb5aefc2" name="a1e1d46688d3a6ed1d20e3669cb5aefc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~basic_endpoint</b> ()</td></tr>
<tr class="memdesc:a1e1d46688d3a6ed1d20e3669cb5aefc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor This function destroys the <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>, cancelling any outstanding asynchronous operations associated with the <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. <br /></td></tr>
<tr class="separator:a1e1d46688d3a6ed1d20e3669cb5aefc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5a4b56044d5b32a8c85030502045c3" id="r_a9f5a4b56044d5b32a8c85030502045c3"><td class="memItemLeft" align="right" valign="top"><a id="a9f5a4b56044d5b32a8c85030502045c3" name="a9f5a4b56044d5b32a8c85030502045c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_endpoint</b> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a9f5a4b56044d5b32a8c85030502045c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor <b>deleted</b> <br /></td></tr>
<tr class="separator:a9f5a4b56044d5b32a8c85030502045c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422611ed21655623c9b254ed2b82b73" id="r_a3422611ed21655623c9b254ed2b82b73"><td class="memItemLeft" align="right" valign="top"><a id="a3422611ed21655623c9b254ed2b82b73" name="a3422611ed21655623c9b254ed2b82b73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_endpoint</b> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html">this_type</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a3422611ed21655623c9b254ed2b82b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor <br /></td></tr>
<tr class="separator:a3422611ed21655623c9b254ed2b82b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d2098ffbe958479234ab7874e81511" id="r_ae3d2098ffbe958479234ab7874e81511"><td class="memItemLeft" align="right" valign="top"><a id="ae3d2098ffbe958479234ab7874e81511" name="ae3d2098ffbe958479234ab7874e81511"></a>
<a class="el" href="classasync__mqtt_1_1basic__endpoint.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="memdesc:ae3d2098ffbe958479234ab7874e81511"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assign operator <b>deleted</b> <br /></td></tr>
<tr class="separator:ae3d2098ffbe958479234ab7874e81511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5cb27f7438e38fa9d41a52365ed6cd" id="r_a2f5cb27f7438e38fa9d41a52365ed6cd"><td class="memItemLeft" align="right" valign="top"><a id="a2f5cb27f7438e38fa9d41a52365ed6cd" name="a2f5cb27f7438e38fa9d41a52365ed6cd"></a>
<a class="el" href="classasync__mqtt_1_1basic__endpoint.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classasync__mqtt_1_1basic__endpoint.html">this_type</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a2f5cb27f7438e38fa9d41a52365ed6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assign operator <br /></td></tr>
<tr class="separator:a2f5cb27f7438e38fa9d41a52365ed6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc02bcef8368f6ff96f1bf9b54bca15" id="r_aecc02bcef8368f6ff96f1bf9b54bca15"><td class="memItemLeft" align="right" valign="top">as::any_io_executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecc02bcef8368f6ff96f1bf9b54bca15">get_executor</a> ()</td></tr>
<tr class="memdesc:aecc02bcef8368f6ff96f1bf9b54bca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">executor getter  <br /></td></tr>
<tr class="separator:aecc02bcef8368f6ff96f1bf9b54bca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada60e5d8c35b1d668a4edf5d0c332f0b" id="r_ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af485b15270d8b1e12746342d4f79cb15">next_layer_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada60e5d8c35b1d668a4edf5d0c332f0b">next_layer</a> () const</td></tr>
<tr class="memdesc:ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_layer getter  <br /></td></tr>
<tr class="separator:ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc21bc830ae4ffd4a7803d3bdd166a21" id="r_acc21bc830ae4ffd4a7803d3bdd166a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af485b15270d8b1e12746342d4f79cb15">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc21bc830ae4ffd4a7803d3bdd166a21">next_layer</a> ()</td></tr>
<tr class="memdesc:acc21bc830ae4ffd4a7803d3bdd166a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_layer getter  <br /></td></tr>
<tr class="separator:acc21bc830ae4ffd4a7803d3bdd166a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4738c4c3261558ac0e1e06bd326ea5" id="r_a8e4738c4c3261558ac0e1e06bd326ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac6d52c82d975d51c9f08627abbf8dec7">lowest_layer_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e4738c4c3261558ac0e1e06bd326ea5">lowest_layer</a> () const</td></tr>
<tr class="memdesc:a8e4738c4c3261558ac0e1e06bd326ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer getter  <br /></td></tr>
<tr class="separator:a8e4738c4c3261558ac0e1e06bd326ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49012d1a2dd798290ae9fb7277e418a0" id="r_a49012d1a2dd798290ae9fb7277e418a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac6d52c82d975d51c9f08627abbf8dec7">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49012d1a2dd798290ae9fb7277e418a0">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a49012d1a2dd798290ae9fb7277e418a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer getter  <br /></td></tr>
<tr class="separator:a49012d1a2dd798290ae9fb7277e418a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8920d50890684fc33eab70c709a90f" id="r_a5e8920d50890684fc33eab70c709a90f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e8920d50890684fc33eab70c709a90f">set_auto_pub_response</a> (bool val)</td></tr>
<tr class="memdesc:a5e8920d50890684fc33eab70c709a90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto publish response setter. Should be called before send()/recv() call.  <br /></td></tr>
<tr class="separator:a5e8920d50890684fc33eab70c709a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e77ec0b180801e25279d35d225a7771" id="r_a5e77ec0b180801e25279d35d225a7771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e77ec0b180801e25279d35d225a7771">set_auto_ping_response</a> (bool val)</td></tr>
<tr class="memdesc:a5e77ec0b180801e25279d35d225a7771"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto pingreq response setter. Should be called before send()/recv() call.  <br /></td></tr>
<tr class="separator:a5e77ec0b180801e25279d35d225a7771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596d2617fa46cd0f37b40afbf4f912df" id="r_a596d2617fa46cd0f37b40afbf4f912df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a596d2617fa46cd0f37b40afbf4f912df">set_auto_map_topic_alias_send</a> (bool val)</td></tr>
<tr class="memdesc:a596d2617fa46cd0f37b40afbf4f912df"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto map (allocate) topic alias on send PUBLISH packet. If all topic aliases are used, then overwrite by LRU algorithm. <br  />
 This function should be called before send() call.  <br /></td></tr>
<tr class="separator:a596d2617fa46cd0f37b40afbf4f912df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f40da2602fb6b22049aafa815782e0" id="r_a70f40da2602fb6b22049aafa815782e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70f40da2602fb6b22049aafa815782e0">set_auto_replace_topic_alias_send</a> (bool val)</td></tr>
<tr class="memdesc:a70f40da2602fb6b22049aafa815782e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto replace topic with corresponding topic alias on send PUBLISH packet. Registering topic alias need to do manually. <br  />
 This function should be called before send() call.  <br /></td></tr>
<tr class="separator:a70f40da2602fb6b22049aafa815782e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304a6bc9c9db1435b06b79217c8375dd" id="r_a304a6bc9c9db1435b06b79217c8375dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a304a6bc9c9db1435b06b79217c8375dd">set_pingresp_recv_timeout</a> (std::chrono::milliseconds duration)</td></tr>
<tr class="memdesc:a304a6bc9c9db1435b06b79217c8375dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeout for receiving PINGRESP packet after PINGREQ packet is sent. If the timer is fired, then the underlying layer is closed from the client side. If the protocol_version is v5, then send DISCONNECT packet with the reason code <a class="el" href="group__disconnect__reason__code.html#gga15697ab1af4bc8686af3e88886db3565ae979b305a6c6521989593b16346de1c0" title="Keep Alive timeout.">disconnect_reason_code::keep_alive_timeout</a> automatically before underlying layer is closed. <br  />
 This function should be called before send() call.  <br /></td></tr>
<tr class="separator:a304a6bc9c9db1435b06b79217c8375dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2259505ae9d0272321f9cabd7b6f45e1" id="r_a2259505ae9d0272321f9cabd7b6f45e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2259505ae9d0272321f9cabd7b6f45e1">set_bulk_write</a> (bool val)</td></tr>
<tr class="memdesc:a2259505ae9d0272321f9cabd7b6f45e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bulk write mode. If true, then concatenate multiple packets' const buffer sequence when send() is called before the previous send() is not completed. Otherwise, send packet one by one. <br  />
 This function should be called before send() call.  <br /></td></tr>
<tr class="separator:a2259505ae9d0272321f9cabd7b6f45e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde955d86b34419c08075af7178fad12" id="r_acde955d86b34419c08075af7178fad12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acde955d86b34419c08075af7178fad12">set_bulk_read_buffer_size</a> (std::size_t val)</td></tr>
<tr class="memdesc:acde955d86b34419c08075af7178fad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bulk read buffer size. If bulk read is enabled, the <code>val</code> parameter specifies the size of the internal <code>async_read_some()</code> buffer. Enabling bulk read can improve throughput but may increase latency. Disabling bulk read can reduce latency but may lower throughput. By default, bulk read is disabled.  <br /></td></tr>
<tr class="separator:acde955d86b34419c08075af7178fad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7274b1d7f83634fd64fe616de1ff3e7f" id="r_a7274b1d7f83634fd64fe616de1ff3e7f"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a7274b1d7f83634fd64fe616de1ff3e7f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7274b1d7f83634fd64fe616de1ff3e7f">async_acquire_unique_packet_id</a> (CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a7274b1d7f83634fd64fe616de1ff3e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id.  <br /></td></tr>
<tr class="separator:a7274b1d7f83634fd64fe616de1ff3e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425e8172d00a1ace4274cf188d626de5" id="r_a425e8172d00a1ace4274cf188d626de5"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a425e8172d00a1ace4274cf188d626de5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a425e8172d00a1ace4274cf188d626de5">async_acquire_unique_packet_id_wait_until</a> (CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a425e8172d00a1ace4274cf188d626de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id. If packet_id is fully acquired, then wait until released.  <br /></td></tr>
<tr class="separator:a425e8172d00a1ace4274cf188d626de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae5c04121fb587cc76dfbba65d52dac" id="r_afae5c04121fb587cc76dfbba65d52dac"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:afae5c04121fb587cc76dfbba65d52dac"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afae5c04121fb587cc76dfbba65d52dac">async_register_packet_id</a> (typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type packet_id, CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:afae5c04121fb587cc76dfbba65d52dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">register packet_id.  <br /></td></tr>
<tr class="separator:afae5c04121fb587cc76dfbba65d52dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad31451430f889136831229fbd89e63" id="r_a3ad31451430f889136831229fbd89e63"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a3ad31451430f889136831229fbd89e63"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ad31451430f889136831229fbd89e63">async_release_packet_id</a> (typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type packet_id, CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a3ad31451430f889136831229fbd89e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">release packet_id.  <br /></td></tr>
<tr class="separator:a3ad31451430f889136831229fbd89e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40082e1947ebe5f8c008f0696d18d6bb" id="r_a40082e1947ebe5f8c008f0696d18d6bb"><td class="memTemplParams" colspan="2">template&lt;typename Packet , typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a40082e1947ebe5f8c008f0696d18d6bb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40082e1947ebe5f8c008f0696d18d6bb">async_send</a> (Packet packet, CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a40082e1947ebe5f8c008f0696d18d6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">send packet users can call send() before the previous send()'s CompletionToken is invoked  <br /></td></tr>
<tr class="separator:a40082e1947ebe5f8c008f0696d18d6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab51bf538fefaad7792f90813d33fc2" id="r_a5ab51bf538fefaad7792f90813d33fc2"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a5ab51bf538fefaad7792f90813d33fc2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ab51bf538fefaad7792f90813d33fc2">async_recv</a> (CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a5ab51bf538fefaad7792f90813d33fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet  <br /></td></tr>
<tr class="separator:a5ab51bf538fefaad7792f90813d33fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e53802d53dfadcb483db978b9c14f8" id="r_a80e53802d53dfadcb483db978b9c14f8"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a80e53802d53dfadcb483db978b9c14f8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80e53802d53dfadcb483db978b9c14f8">async_recv</a> (std::set&lt; <a class="el" href="group__packet.html#gad751afab4b1771811a82fcc3f34938b4">control_packet_type</a> &gt; types, CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a80e53802d53dfadcb483db978b9c14f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet if packet is not filterd, then next recv() starts automatically. if receive error happenes, then token would be invoked.  <br /></td></tr>
<tr class="separator:a80e53802d53dfadcb483db978b9c14f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2661e94a1f7f06832fe0d3604ba66" id="r_a14c2661e94a1f7f06832fe0d3604ba66"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a14c2661e94a1f7f06832fe0d3604ba66"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14c2661e94a1f7f06832fe0d3604ba66">async_recv</a> (<a class="el" href="group__endpoint.html#gaed6ebca93cac28c67f2b4fb8641e775a">filter</a> fil, std::set&lt; <a class="el" href="group__packet.html#gad751afab4b1771811a82fcc3f34938b4">control_packet_type</a> &gt; types, CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a14c2661e94a1f7f06832fe0d3604ba66"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet if packet is not filterd, then next recv() starts automatically. if receive error happenes, then token would be invoked.  <br /></td></tr>
<tr class="separator:a14c2661e94a1f7f06832fe0d3604ba66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c200119c5728f566057bb43b96a952" id="r_a75c200119c5728f566057bb43b96a952"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a75c200119c5728f566057bb43b96a952"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75c200119c5728f566057bb43b96a952">async_close</a> (CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a75c200119c5728f566057bb43b96a952"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the underlying connection  <br /></td></tr>
<tr class="separator:a75c200119c5728f566057bb43b96a952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeb968d96506e91e1eb69e6ff22925c" id="r_abbeb968d96506e91e1eb69e6ff22925c"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:abbeb968d96506e91e1eb69e6ff22925c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abbeb968d96506e91e1eb69e6ff22925c">async_restore_packets</a> (std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt; pvs, CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:abbeb968d96506e91e1eb69e6ff22925c"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore packets the restored packets would automatically send when CONNACK packet is received  <br /></td></tr>
<tr class="separator:abbeb968d96506e91e1eb69e6ff22925c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55bcc2381f5f0c95b19ddff7adca6c0" id="r_ac55bcc2381f5f0c95b19ddff7adca6c0"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:ac55bcc2381f5f0c95b19ddff7adca6c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac55bcc2381f5f0c95b19ddff7adca6c0">async_get_stored_packets</a> (CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:ac55bcc2381f5f0c95b19ddff7adca6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stored packets  <br /></td></tr>
<tr class="separator:ac55bcc2381f5f0c95b19ddff7adca6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44218533516f16e8847eabad24069b69" id="r_a44218533516f16e8847eabad24069b69"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a44218533516f16e8847eabad24069b69"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44218533516f16e8847eabad24069b69">async_regulate_for_store</a> (<a class="el" href="classasync__mqtt_1_1v5_1_1basic__publish__packet.html">v5::basic_publish_packet</a>&lt; PacketIdBytes &gt; packet, CompletionToken &amp;&amp;token=as::default_completion_token_t&lt; <a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a> &gt;{})</td></tr>
<tr class="memdesc:a44218533516f16e8847eabad24069b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">regulate publish packet for store remove topic alias from the packet and extract the topic name  <br /></td></tr>
<tr class="separator:a44218533516f16e8847eabad24069b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864c9c46f655e82a8cbb93d2725f0e0" id="r_a9864c9c46f655e82a8cbb93d2725f0e0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9864c9c46f655e82a8cbb93d2725f0e0">acquire_unique_packet_id</a> ()</td></tr>
<tr class="memdesc:a9864c9c46f655e82a8cbb93d2725f0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id.  <br /></td></tr>
<tr class="separator:a9864c9c46f655e82a8cbb93d2725f0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff45fdd6e9bc61001b1ac936040c01" id="r_adaff45fdd6e9bc61001b1ac936040c01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaff45fdd6e9bc61001b1ac936040c01">register_packet_id</a> (typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type packet_id)</td></tr>
<tr class="memdesc:adaff45fdd6e9bc61001b1ac936040c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">register packet_id.  <br /></td></tr>
<tr class="separator:adaff45fdd6e9bc61001b1ac936040c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72fa838272da0e140e5ad1acf24463b" id="r_ae72fa838272da0e140e5ad1acf24463b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae72fa838272da0e140e5ad1acf24463b">release_packet_id</a> (typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type packet_id)</td></tr>
<tr class="memdesc:ae72fa838272da0e140e5ad1acf24463b"><td class="mdescLeft">&#160;</td><td class="mdescRight">release packet_id.  <br /></td></tr>
<tr class="separator:ae72fa838272da0e140e5ad1acf24463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c54a4deadb8706eafe3f56fc59eca07" id="r_a5c54a4deadb8706eafe3f56fc59eca07"><td class="memItemLeft" align="right" valign="top">std::set&lt; typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c54a4deadb8706eafe3f56fc59eca07">get_qos2_publish_handled_pids</a> () const</td></tr>
<tr class="memdesc:a5c54a4deadb8706eafe3f56fc59eca07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get processed but not released QoS2 packet ids This function should be called after disconnection.  <br /></td></tr>
<tr class="separator:a5c54a4deadb8706eafe3f56fc59eca07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfa56073b24d3efa6c8ed881295e45e" id="r_abcfa56073b24d3efa6c8ed881295e45e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcfa56073b24d3efa6c8ed881295e45e">restore_qos2_publish_handled_pids</a> (std::set&lt; typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type &gt; pids)</td></tr>
<tr class="memdesc:abcfa56073b24d3efa6c8ed881295e45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore processed but not released QoS2 packet ids This function should be called before receive the first publish.  <br /></td></tr>
<tr class="separator:abcfa56073b24d3efa6c8ed881295e45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfe47bd9ab1590e66f110e3dbe1087e" id="r_a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dfe47bd9ab1590e66f110e3dbe1087e">restore_packets</a> (std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt; pvs)</td></tr>
<tr class="memdesc:a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore packets the restored packets would automatically send when CONNACK packet is received  <br /></td></tr>
<tr class="separator:a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed8d45ffcfb114533d8de5ddddb4f92" id="r_a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ed8d45ffcfb114533d8de5ddddb4f92">get_stored_packets</a> () const</td></tr>
<tr class="memdesc:a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stored packets sotred packets mean inflight packets.  <br /></td></tr>
<tr class="separator:a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbabd5f427b1cb18d61ac49c7bbf83b" id="r_a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mqtt.html#ga133d6d106d4e527d07fea2d12544c0c0">protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbabd5f427b1cb18d61ac49c7bbf83b">get_protocol_version</a> () const</td></tr>
<tr class="memdesc:a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MQTT protocol version  <br /></td></tr>
<tr class="separator:a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb94fd1419e3213494abfec9a1ba976f" id="r_afb94fd1419e3213494abfec9a1ba976f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb94fd1419e3213494abfec9a1ba976f">is_publish_processing</a> (typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type pid) const</td></tr>
<tr class="memdesc:afb94fd1419e3213494abfec9a1ba976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MQTT PUBLISH packet processing status.  <br /></td></tr>
<tr class="separator:afb94fd1419e3213494abfec9a1ba976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60da2cf90573114b7a0bfb720cf30a9b" id="r_a60da2cf90573114b7a0bfb720cf30a9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60da2cf90573114b7a0bfb720cf30a9b">regulate_for_store</a> (<a class="el" href="classasync__mqtt_1_1v5_1_1basic__publish__packet.html">v5::basic_publish_packet</a>&lt; PacketIdBytes &gt; &amp;packet, <a class="el" href="group__error.html#gaa100a3fca173f12e33f3b5711710033d">error_code</a> &amp;ec) const</td></tr>
<tr class="memdesc:a60da2cf90573114b7a0bfb720cf30a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regulate publish packet for store If topic is empty, extract topic from topic alias, and remove topic alias Otherwise, remove topic alias if exists.  <br /></td></tr>
<tr class="separator:a60da2cf90573114b7a0bfb720cf30a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50d613544ac977dbc69c64c367eeb32" id="r_ad50d613544ac977dbc69c64c367eeb32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad50d613544ac977dbc69c64c367eeb32">set_pingreq_send_interval</a> (std::chrono::milliseconds duration)</td></tr>
<tr class="memdesc:ad50d613544ac977dbc69c64c367eeb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PINGREQ packet sending interval.  <br /></td></tr>
<tr class="separator:ad50d613544ac977dbc69c64c367eeb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:ga2e1a75540d6fe007c2a768600ad6d8cb" id="r_ga2e1a75540d6fe007c2a768600ad6d8cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, typename NextLayer &gt; </td></tr>
<tr class="memitem:ga2e1a75540d6fe007c2a768600ad6d8cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__endpoint.html#ga2e1a75540d6fe007c2a768600ad6d8cb">endpoint</a> = <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt;Role, 2, NextLayer&gt;</td></tr>
<tr class="memdesc:ga2e1a75540d6fe007c2a768600ad6d8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2). This is for typical usecase.  <br /></td></tr>
<tr class="separator:ga2e1a75540d6fe007c2a768600ad6d8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer&gt;<br />
class async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt;</div><p>MQTT endpoint corresponding to the connection. </p>
<h4><a class="anchor" id="autotoc_md2"></a>
Thread Safety</h4>
<ul>
<li>Distinct objects: Safe</li>
<li>Shared objects: Unsafe</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Role</td><td>role for packet sendable checking </td></tr>
    <tr><td class="paramname">PacketIdBytes</td><td>MQTT spec is 2. You can use <code>endpoint</code> for that. </td></tr>
    <tr><td class="paramname">NextLayer</td><td>Just next layer for <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. mqtt, mqtts, ws, and wss are predefined. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abc8fe2d40a34da40817c6624a086dc25" name="abc8fe2d40a34da40817c6624a086dc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8fe2d40a34da40817c6624a086dc25">&#9670;&#160;</a></span>basic_endpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::basic_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mqtt.html#ga133d6d106d4e527d07fea2d12544c0c0">protocol_version</a></td>          <td class="paramname"><span class="paramname"><em>ver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types for the next layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ver</td><td>MQTT protocol version client can set v5 or v3_1_1, in addition server can set undetermined </td></tr>
    <tr><td class="paramname">args</td><td>args for the next layer.<ul>
<li>There are predefined next layer types:<ul>
<li><a class="el" href="group__predefined__layer__mqtt.html#gaf0fedc2324340e8a97a85d091e912983" title="Type alias of Boost.Asio TCP socket.">protocol::mqtt</a></li>
<li><a class="el" href="group__predefined__layer__mqtts.html#ga2c89e72af39c22d974e557ad822a5601" title="Type alias of boost::asio::ssl::stream of mqtt.">protocol::mqtts</a></li>
<li><a class="el" href="group__predefined__layer__ws.html#gafa0029e1fe1da9ffc3e87e073cc1930c" title="Type alias of boost::beast::websocket::stream of mqtt.">protocol::ws</a></li>
<li><a class="el" href="group__predefined__layer__wss.html#ga6ca99bfaf9ccf4acfac8209e5dd979e5" title="Type alias of boost::beast::websocket::stream of mqtts async_underlying_handshake function can be cal...">protocol::wss</a> </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9864c9c46f655e82a8cbb93d2725f0e0" name="a9864c9c46f655e82a8cbb93d2725f0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9864c9c46f655e82a8cbb93d2725f0e0">&#9670;&#160;</a></span>acquire_unique_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>acuire unique packet_id. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;typename basic_packet_id_type&lt;PacketIdBytes&gt;::type&gt; if acquired return acquired packet id, otherwise std::nullopt </dd></dl>

</div>
</div>
<a id="a7274b1d7f83634fd64fe616de1ff3e7f" name="a7274b1d7f83634fd64fe616de1ff3e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7274b1d7f83634fd64fe616de1ff3e7f">&#9670;&#160;</a></span>async_acquire_unique_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>acuire unique packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code, typename basic_packet_id_type&lt;PacketIdBytes&gt;::type) </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
<li>cancellation_type::total </li>
</ul>

</div>
</div>
<a id="a425e8172d00a1ace4274cf188d626de5" name="a425e8172d00a1ace4274cf188d626de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425e8172d00a1ace4274cf188d626de5">&#9670;&#160;</a></span>async_acquire_unique_packet_id_wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_acquire_unique_packet_id_wait_until </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>acuire unique packet_id. If packet_id is fully acquired, then wait until released. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code, typename basic_packet_id_type&lt;PacketIdBytes&gt;::type) </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
<li>cancellation_type::total </li>
</ul>

</div>
</div>
<a id="a75c200119c5728f566057bb43b96a952" name="a75c200119c5728f566057bb43b96a952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c200119c5728f566057bb43b96a952">&#9670;&#160;</a></span>async_close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_close </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>close the underlying connection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void() </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial </li>
</ul>

</div>
</div>
<a id="ac55bcc2381f5f0c95b19ddff7adca6c0" name="ac55bcc2381f5f0c95b19ddff7adca6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55bcc2381f5f0c95b19ddff7adca6c0">&#9670;&#160;</a></span>async_get_stored_packets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_get_stored_packets </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get stored packets </p>
<ul>
<li>stored packets mean inflight packets.<ul>
<li>PUBLISH packet (QoS1) not received PUBACK packet</li>
<li>PUBLISH packet (QoS2) not received PUBREC packet</li>
<li>PUBREL packet not received PUBCOMP packet</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code, std::vector&lt;basic_store_packet_variant&lt;PacketIdBytes&gt;&gt;) </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
<li>cancellation_type::total </li>
</ul>

</div>
</div>
<a id="a5ab51bf538fefaad7792f90813d33fc2" name="a5ab51bf538fefaad7792f90813d33fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab51bf538fefaad7792f90813d33fc2">&#9670;&#160;</a></span>async_recv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_recv </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>receive packet </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code, packet_variant_type) </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
</ul>
<p>if they are also supported by the NextLayer type's async_read_some operation. </p>

</div>
</div>
<a id="a14c2661e94a1f7f06832fe0d3604ba66" name="a14c2661e94a1f7f06832fe0d3604ba66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c2661e94a1f7f06832fe0d3604ba66">&#9670;&#160;</a></span>async_recv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__endpoint.html#gaed6ebca93cac28c67f2b4fb8641e775a">filter</a></td>          <td class="paramname"><span class="paramname"><em>fil</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="group__packet.html#gad751afab4b1771811a82fcc3f34938b4">control_packet_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>receive packet if packet is not filterd, then next recv() starts automatically. if receive error happenes, then token would be invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fil</td><td>if <code>match</code> then matched types are targets. if <code>except</code> then not matched types are targets. </td></tr>
    <tr><td class="paramname">types</td><td>target control_packet_types </td></tr>
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code, packet_variant_type) </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
</ul>
<p>if they are also supported by the NextLayer type's async_read_some operation. </p>

</div>
</div>
<a id="a80e53802d53dfadcb483db978b9c14f8" name="a80e53802d53dfadcb483db978b9c14f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e53802d53dfadcb483db978b9c14f8">&#9670;&#160;</a></span>async_recv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_recv </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="group__packet.html#gad751afab4b1771811a82fcc3f34938b4">control_packet_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>receive packet if packet is not filterd, then next recv() starts automatically. if receive error happenes, then token would be invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>target control_packet_types </td></tr>
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code, packet_variant_type) </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
</ul>
<p>if they are also supported by the NextLayer type's async_read_some operation. </p>

</div>
</div>
<a id="afae5c04121fb587cc76dfbba65d52dac" name="afae5c04121fb587cc76dfbba65d52dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae5c04121fb587cc76dfbba65d52dac">&#9670;&#160;</a></span>async_register_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_register_packet_id </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type</td>          <td class="paramname"><span class="paramname"><em>packet_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to register </td></tr>
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code)</li>
<li>success if packet is acquired, otherwise packet_identifier_fully_used </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
<li>cancellation_type::total </li>
</ul>

</div>
</div>
<a id="a44218533516f16e8847eabad24069b69" name="a44218533516f16e8847eabad24069b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44218533516f16e8847eabad24069b69">&#9670;&#160;</a></span>async_regulate_for_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_regulate_for_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1v5_1_1basic__publish__packet.html">v5::basic_publish_packet</a>&lt; PacketIdBytes &gt;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>regulate publish packet for store remove topic alias from the packet and extract the topic name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>target packet to regulate </td></tr>
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code, v5::basic_publish_packet&lt;PacketIdBytes&gt;) </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
<li>cancellation_type::total </li>
</ul>

</div>
</div>
<a id="a3ad31451430f889136831229fbd89e63" name="a3ad31451430f889136831229fbd89e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad31451430f889136831229fbd89e63">&#9670;&#160;</a></span>async_release_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_release_packet_id </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type</td>          <td class="paramname"><span class="paramname"><em>packet_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to release </td></tr>
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void() </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
<li>cancellation_type::total </li>
</ul>

</div>
</div>
<a id="abbeb968d96506e91e1eb69e6ff22925c" name="abbeb968d96506e91e1eb69e6ff22925c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbeb968d96506e91e1eb69e6ff22925c">&#9670;&#160;</a></span>async_restore_packets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_restore_packets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>pvs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>restore packets the restored packets would automatically send when CONNACK packet is received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvs</td><td>packets to restore </td></tr>
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void() </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
<li>cancellation_type::total </li>
</ul>

</div>
</div>
<a id="a40082e1947ebe5f8c008f0696d18d6bb" name="a40082e1947ebe5f8c008f0696d18d6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40082e1947ebe5f8c008f0696d18d6bb">&#9670;&#160;</a></span>async_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
<div class="memtemplate">
template&lt;typename Packet , typename CompletionToken  = as::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::async_send </td>
          <td>(</td>
          <td class="paramtype">Packet</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">as::default_completion_token_t&lt;&#160;<a class="el" href="#a631e1e2d54cfc10767b1d8c29639441d">executor_type</a>&#160;&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send packet users can call send() before the previous send()'s CompletionToken is invoked </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>packet to send </td></tr>
    <tr><td class="paramname">token</td><td><ul>
<li>CompletionToken<ul>
<li>Signature: void(error_code) </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd></dd></dl>
<p>This asynchronous operation supports cancellation for the following <a href="https://www.boost.org/doc/html/boost_asio/reference/cancellation_type.html">boost::asio::cancellation_type</a> values:</p><ul>
<li>cancellation_type::terminal</li>
<li>cancellation_type::partial</li>
</ul>
<p>if they are also supported by the NextLayer type's async_write_some operation. </p>

</div>
</div>
<a id="aecc02bcef8368f6ff96f1bf9b54bca15" name="aecc02bcef8368f6ff96f1bf9b54bca15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc02bcef8368f6ff96f1bf9b54bca15">&#9670;&#160;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">as::any_io_executor <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>executor getter </p>
<dl class="section return"><dt>Returns</dt><dd>return internal stream's executor </dd></dl>

</div>
</div>
<a id="a9cbabd5f427b1cb18d61ac49c7bbf83b" name="a9cbabd5f427b1cb18d61ac49c7bbf83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbabd5f427b1cb18d61ac49c7bbf83b">&#9670;&#160;</a></span>get_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mqtt.html#ga133d6d106d4e527d07fea2d12544c0c0">protocol_version</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::get_protocol_version </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get MQTT protocol version </p>
<dl class="section return"><dt>Returns</dt><dd>MQTT protocol version </dd></dl>

</div>
</div>
<a id="a5c54a4deadb8706eafe3f56fc59eca07" name="a5c54a4deadb8706eafe3f56fc59eca07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c54a4deadb8706eafe3f56fc59eca07">&#9670;&#160;</a></span>get_qos2_publish_handled_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::get_qos2_publish_handled_pids </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get processed but not released QoS2 packet ids This function should be called after disconnection. </p>
<dl class="section return"><dt>Returns</dt><dd>set of packet_ids </dd></dl>

</div>
</div>
<a id="a5ed8d45ffcfb114533d8de5ddddb4f92" name="a5ed8d45ffcfb114533d8de5ddddb4f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed8d45ffcfb114533d8de5ddddb4f92">&#9670;&#160;</a></span>get_stored_packets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::get_stored_packets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get stored packets sotred packets mean inflight packets. </p>
<ul>
<li>PUBLISH packet (QoS1) not received PUBACK packet</li>
<li>PUBLISH packet (QoS1) not received PUBREC packet</li>
<li>PUBREL packet not received PUBCOMP packet <dl class="section return"><dt>Returns</dt><dd>std::vector&lt;basic_store_packet_variant&lt;PacketIdBytes&gt;&gt; </dd></dl>
</li>
</ul>

</div>
</div>
<a id="afb94fd1419e3213494abfec9a1ba976f" name="afb94fd1419e3213494abfec9a1ba976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb94fd1419e3213494abfec9a1ba976f">&#9670;&#160;</a></span>is_publish_processing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::is_publish_processing </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type</td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MQTT PUBLISH packet processing status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>packet_id corresponding to the publish packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the packet is processing, then true, otherwise false. </dd></dl>

</div>
</div>
<a id="a49012d1a2dd798290ae9fb7277e418a0" name="a49012d1a2dd798290ae9fb7277e418a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49012d1a2dd798290ae9fb7277e418a0">&#9670;&#160;</a></span>lowest_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac6d52c82d975d51c9f08627abbf8dec7">lowest_layer_type</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lowest_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the lowest_layer </dd></dl>

</div>
</div>
<a id="a8e4738c4c3261558ac0e1e06bd326ea5" name="a8e4738c4c3261558ac0e1e06bd326ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4738c4c3261558ac0e1e06bd326ea5">&#9670;&#160;</a></span>lowest_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac6d52c82d975d51c9f08627abbf8dec7">lowest_layer_type</a> const  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lowest_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the lowest_layer </dd></dl>

</div>
</div>
<a id="acc21bc830ae4ffd4a7803d3bdd166a21" name="acc21bc830ae4ffd4a7803d3bdd166a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc21bc830ae4ffd4a7803d3bdd166a21">&#9670;&#160;</a></span>next_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af485b15270d8b1e12746342d4f79cb15">next_layer_type</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>next_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the next_layer </dd></dl>

</div>
</div>
<a id="ada60e5d8c35b1d668a4edf5d0c332f0b" name="ada60e5d8c35b1d668a4edf5d0c332f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada60e5d8c35b1d668a4edf5d0c332f0b">&#9670;&#160;</a></span>next_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af485b15270d8b1e12746342d4f79cb15">next_layer_type</a> const  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>next_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the next_layer </dd></dl>

</div>
</div>
<a id="adaff45fdd6e9bc61001b1ac936040c01" name="adaff45fdd6e9bc61001b1ac936040c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaff45fdd6e9bc61001b1ac936040c01">&#9670;&#160;</a></span>register_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type</td>          <td class="paramname"><span class="paramname"><em>packet_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If true, success, otherwise the packet_id has already been used. </dd></dl>

</div>
</div>
<a id="a60da2cf90573114b7a0bfb720cf30a9b" name="a60da2cf90573114b7a0bfb720cf30a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60da2cf90573114b7a0bfb720cf30a9b">&#9670;&#160;</a></span>regulate_for_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::regulate_for_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1v5_1_1basic__publish__packet.html">v5::basic_publish_packet</a>&lt; PacketIdBytes &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__error.html#gaa100a3fca173f12e33f3b5711710033d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regulate publish packet for store If topic is empty, extract topic from topic alias, and remove topic alias Otherwise, remove topic alias if exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>packet to regulate </td></tr>
    <tr><td class="paramname">ec</td><td>error_code for repoting error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae72fa838272da0e140e5ad1acf24463b" name="ae72fa838272da0e140e5ad1acf24463b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72fa838272da0e140e5ad1acf24463b">&#9670;&#160;</a></span>release_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type</td>          <td class="paramname"><span class="paramname"><em>packet_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dfe47bd9ab1590e66f110e3dbe1087e" name="a6dfe47bd9ab1590e66f110e3dbe1087e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfe47bd9ab1590e66f110e3dbe1087e">&#9670;&#160;</a></span>restore_packets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::restore_packets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; PacketIdBytes &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>pvs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>restore packets the restored packets would automatically send when CONNACK packet is received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvs</td><td>packets to restore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcfa56073b24d3efa6c8ed881295e45e" name="abcfa56073b24d3efa6c8ed881295e45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfa56073b24d3efa6c8ed881295e45e">&#9670;&#160;</a></span>restore_qos2_publish_handled_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::restore_qos2_publish_handled_pids </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; typename <a class="el" href="structasync__mqtt_1_1basic__packet__id__type.html">basic_packet_id_type</a>&lt; PacketIdBytes &gt;::type &gt;</td>          <td class="paramname"><span class="paramname"><em>pids</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore processed but not released QoS2 packet ids This function should be called before receive the first publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pids</td><td>packet ids </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a596d2617fa46cd0f37b40afbf4f912df" name="a596d2617fa46cd0f37b40afbf4f912df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596d2617fa46cd0f37b40afbf4f912df">&#9670;&#160;</a></span>set_auto_map_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_auto_map_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>auto map (allocate) topic alias on send PUBLISH packet. If all topic aliases are used, then overwrite by LRU algorithm. <br  />
 This function should be called before send() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically mapping. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable auto mapping, otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e77ec0b180801e25279d35d225a7771" name="a5e77ec0b180801e25279d35d225a7771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e77ec0b180801e25279d35d225a7771">&#9670;&#160;</a></span>set_auto_ping_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_auto_ping_response </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>auto pingreq response setter. Should be called before send()/recv() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically sending. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, puback, pubrec, pubrel, and pubcomp are automatically sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e8920d50890684fc33eab70c709a90f" name="a5e8920d50890684fc33eab70c709a90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8920d50890684fc33eab70c709a90f">&#9670;&#160;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>auto publish response setter. Should be called before send()/recv() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically sending. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, puback, pubrec, pubrel, and pubcomp are automatically sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f40da2602fb6b22049aafa815782e0" name="a70f40da2602fb6b22049aafa815782e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f40da2602fb6b22049aafa815782e0">&#9670;&#160;</a></span>set_auto_replace_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_auto_replace_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>auto replace topic with corresponding topic alias on send PUBLISH packet. Registering topic alias need to do manually. <br  />
 This function should be called before send() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically replacing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable auto replacing, otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acde955d86b34419c08075af7178fad12" name="acde955d86b34419c08075af7178fad12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde955d86b34419c08075af7178fad12">&#9670;&#160;</a></span>set_bulk_read_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_bulk_read_buffer_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bulk read buffer size. If bulk read is enabled, the <code>val</code> parameter specifies the size of the internal <code>async_read_some()</code> buffer. Enabling bulk read can improve throughput but may increase latency. Disabling bulk read can reduce latency but may lower throughput. By default, bulk read is disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>If set to 0, bulk read is disabled. Otherwise, it specifies the buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2259505ae9d0272321f9cabd7b6f45e1" name="a2259505ae9d0272321f9cabd7b6f45e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2259505ae9d0272321f9cabd7b6f45e1">&#9670;&#160;</a></span>set_bulk_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_bulk_write </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bulk write mode. If true, then concatenate multiple packets' const buffer sequence when send() is called before the previous send() is not completed. Otherwise, send packet one by one. <br  />
 This function should be called before send() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default bulk write mode is false (disabled) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable bulk write mode, otherwise disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad50d613544ac977dbc69c64c367eeb32" name="ad50d613544ac977dbc69c64c367eeb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50d613544ac977dbc69c64c367eeb32">&#9670;&#160;</a></span>set_pingreq_send_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_pingreq_send_interval </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds</td>          <td class="paramname"><span class="paramname"><em>duration</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set PINGREQ packet sending interval. </p>
<dl class="section note"><dt>Note</dt><dd>By default, PINGREQ packet sending interval is set the same value as CONNECT packet keep alive seconds. This function overrides it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>if zero, timer is not set; otherwise duration is set. The minimum resolution is in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a304a6bc9c9db1435b06b79217c8375dd" name="a304a6bc9c9db1435b06b79217c8375dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304a6bc9c9db1435b06b79217c8375dd">&#9670;&#160;</a></span>set_pingresp_recv_timeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__role.html#ga83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, typename NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; Role, PacketIdBytes, NextLayer &gt;::set_pingresp_recv_timeout </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds</td>          <td class="paramname"><span class="paramname"><em>duration</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set timeout for receiving PINGRESP packet after PINGREQ packet is sent. If the timer is fired, then the underlying layer is closed from the client side. If the protocol_version is v5, then send DISCONNECT packet with the reason code <a class="el" href="group__disconnect__reason__code.html#gga15697ab1af4bc8686af3e88886db3565ae979b305a6c6521989593b16346de1c0" title="Keep Alive timeout.">disconnect_reason_code::keep_alive_timeout</a> automatically before underlying layer is closed. <br  />
 This function should be called before send() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default timeout is not set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>if zero, timer is not set; otherwise duration is set. The minimum resolution is in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/kondo/work/async_mqtt/include/async_mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
<li>/home/kondo/work/async_mqtt/include/async_mqtt/<a class="el" href="endpoint__fwd_8hpp_source.html">endpoint_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>async_mqtt</b></li><li class="navelem"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
