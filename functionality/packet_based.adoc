:last-update-label!:
:am-version: latest
:source-highlighter: rouge
:rouge-style: base16.monokai

ifdef::env-github[:am-base-path: ../../main]
ifndef::env-github[:am-base-path: ../..]
ifdef::env-github[:api-base: link:https://redboltz.github.io/async_mqtt/doc/{am-version}/html]
ifndef::env-github[:api-base: link:../api]

= Packet-Based APIs

`async_mqtt` automatically updates the endpoint's internal state when sending and receiving packets.

== MQTT v3.1.1

=== {api-base}/++classasync__mqtt_1_1v3__1__1_1_1connect__packet.html++[CONNECT Packet]

==== Send (client only)

* If `keep_alive` is set to a value greater than 0, `PINGREQ` packet sending is configured. A `PINGREQ` packet is sent if no other packet is sent within the `keep_alive` seconds.
* If `clean_session` is set to true, the endpoint's Session State is cleared. See xref:keep_session.adoc[keeps session].

==== Receive (server only)

* If `keep_alive` is set to a value greater than 0, `PINGREQ` receiving timeout is configured. If no packet is received within `keep_alive` * 1.5 seconds after the last packet, the connection is disconnected.
* If `clean_session` is set to false, the session state storage is configured. See xref:keep_session.adoc[keeps session].

=== {api-base}/++classasync__mqtt_1_1v3__1__1_1_1connack__packet.html++[CONNACK Packet]

==== Receive (client only)

* If `session_present` is set to false, the endpoint's Session State is cleared. The configured session state setting is retained, meaning that if a PUBLISH packet with QoS 1 or QoS 2 is sent, it will be stored. If `session_present` is set to true, stored PUBLISH and PUBREL packets are sent.

== MQTT v5.0

=== {api-base}/++classasync__mqtt_1_1v5_1_1connect__packet.html++[CONNECT Packet]

==== Send (client only)

* If `clean_start` is set, the endpoint's Session State is cleared. See xref:keep_session.adoc[Keep session].
* If {api-base}/++classasync__mqtt_1_1property_1_1topic__alias__maximum.html++[`topic_alias_maximum`] is set, prepare the `topic name` - `topic alias` map for sending. See xref:topic_alias.adoc[Topic Alias].
* If {api-base}/++classasync__mqtt_1_1property_1_1receive__maximum.html++[`receive_maximum`] is set, the receive maximum for incoming packets is configured. See xref:receive_maximum.adoc[Receive Maximum].
* If {api-base}/++classasync__mqtt_1_1property_1_1maximum__packet__size.html++[`maximum_packet_size`] is set, the maximum packet size for incoming packets is configured. See xref:maximum_packet_size.adoc[Maximum Packet Size].
* If {api-base}/++classasync__mqtt_1_1property_1_1session__expiry__interval.html++[`session_expiry_interval`] is set to a value greater than 0, session state storage is configured. See xref:keep_session.adoc[Keep session].

==== Receive (server only)

* If `keep_alive` is set to a value greater than 0, `PINGREQ` receiving timeout is configured. If no packet is received within `keep_alive` * 1.5 seconds after the last packet, the connection is disconnected.
* If {api-base}/++classasync__mqtt_1_1property_1_1topic__alias__maximum.html++[`topic_alias_maximum`] is set, prepare the `topic name` - `topic alias` map for receiving. See xref:topic_alias.adoc[Topic Alias].
* If {api-base}/++classasync__mqtt_1_1property_1_1receive__maximum.html++[`receive_maximum`] is set, the receive maximum for outgoing packets is configured. See xref:receive_maximum.adoc[Receive Maximum].
* If {api-base}/++classasync__mqtt_1_1property_1_1maximum__packet__size.html++[`maximum_packet_size`] is set, the maximum packet size for outgoing packets is configured. See xref:maximum_packet_size.adoc[Maximum Packet Size].
* If {api-base}/++classasync__mqtt_1_1property_1_1session__expiry__interval.html++[`session_expiry_interval`] is set to a value greater than 0, session state storage is configured. See xref:keep_session.adoc[Keep session].

=== {api-base}/++classasync__mqtt_1_1v5_1_1connack__packet.html++[CONNACK Packet]

==== Send (server only)

* If {api-base}/++classasync__mqtt_1_1property_1_1topic__alias__maximum.html++[`topic_alias_maximum`] is set, prepare the `topic name` - `topic alias` map for sending. See xref:topic_alias.adoc[Topic Alias].
* If {api-base}/++classasync__mqtt_1_1property_1_1receive__maximum.html++[`receive_maximum`] is set, the receive maximum for incoming packets is configured. See xref:receive_maximum.adoc[Receive Maximum].
* If {api-base}/++classasync__mqtt_1_1property_1_1maximum__packet__size.html++[`maximum_packet_size`] is set, the maximum packet size for incoming packets is configured. See xref:maximum_packet_size.adoc[Maximum Packet Size].
* If {api-base}/++classasync__mqtt_1_1property_1_1session__expiry__interval.html++[`session_expiry_interval`] is set to a value greater than 0, session state storage is configured. See xref:keep_session.adoc[Keep session].

==== Receive (client only)

* If `session_present` is set to false, the endpoint's Session State is cleared. The configured session state setting is retained, meaning that if a PUBLISH packet with QoS 1 or QoS 2 is sent, it will be stored. If `session_present` is set to true, stored PUBLISH and PUBREL packets are sent.
* If {api-base}/++classasync__mqtt_1_1property_1_1topic__alias__maximum.html++[`topic_alias_maximum`] is set, prepare the `topic name` - `topic alias` map for receiving. See xref:topic_alias.adoc[Topic Alias].
* If {api-base}/++classasync__mqtt_1_1property_1_1receive__maximum.html++[`receive_maximum`] is set, the receive maximum for outgoing packets is configured. See xref:receive_maximum.adoc[Receive Maximum].
* If {api-base}/++classasync__mqtt_1_1property_1_1maximum__packet__size.html++[`maximum_packet_size`] is set, the maximum packet size for outgoing packets is configured. See xref:maximum_packet_size.adoc[Maximum Packet Size].
* If {api-base}/++classasync__mqtt_1_1property_1_1server__keep__alive.html++[`server_keep_alive`] is set, `PINGREQ` packet sending is overridden. A `PINGREQ` packet is sent if no other packet is sent within the `server_keep_alive` seconds.
