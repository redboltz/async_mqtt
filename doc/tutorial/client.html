<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<title>Client</title>
<style>
/*! Copyright (C) 2019, TomTom (http://tomtom.com).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Extension of the AsciiDoctor CSS for AsciiDoxy.
 * Adding:
 * - Floating multipage navigation.
 */
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

/* Multipage navigation */
div#navigation {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1000;
}
div#navigation table {
    margin-bottom: 0;
}
@media screen and (min-width: 768px) {
    body.toc2 div#navigation {
        left: 15em;
    }
    body.toc2.toc-right div#navigation {
        right: 15em;
    }
}
@media screen and (min-width: 1280px) {
    body.toc2 div#navigation {
        left: 20em;
    }
    body.toc2.toc-right div#navigation {
        right: 20em;
    }
}

</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #f8f8f2;
  background-color: #272822;
}
pre.rouge .err {
  color: #272822;
  background-color: #f92672;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #75715e;
}
pre.rouge .cp {
  color: #f4bf75;
}
pre.rouge .nt {
  color: #f4bf75;
}
pre.rouge .o, pre.rouge .ow {
  color: #f8f8f2;
}
pre.rouge .p, pre.rouge .pi {
  color: #f8f8f2;
}
pre.rouge .gi {
  color: #a6e22e;
}
pre.rouge .gd {
  color: #f92672;
}
pre.rouge .gh {
  color: #66d9ef;
  background-color: #272822;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kv {
  color: #ae81ff;
}
pre.rouge .kc {
  color: #fd971f;
}
pre.rouge .kt {
  color: #fd971f;
}
pre.rouge .kd {
  color: #fd971f;
}
pre.rouge .s, pre.rouge .sb, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1 {
  color: #a6e22e;
}
pre.rouge .sa {
  color: #ae81ff;
}
pre.rouge .sr {
  color: #a1efe4;
}
pre.rouge .si {
  color: #cc6633;
}
pre.rouge .se {
  color: #cc6633;
}
pre.rouge .nn {
  color: #f4bf75;
}
pre.rouge .nc {
  color: #f4bf75;
}
pre.rouge .no {
  color: #f4bf75;
}
pre.rouge .na {
  color: #66d9ef;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #a6e22e;
}
pre.rouge .ss {
  color: #a6e22e;
}
</style>
</head>
<body class="article">
<div id="header">
<h1>Client</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_create_client">Create client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, choose MQTT protocol version (v3.1.1 or v5), and then choose underlying layer.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/layer.svg" alt="layer structure">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mqtt">mqtt</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">as</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ioc</span><span class="p">;</span>

    <span class="c1">// To get IP address from hostname</span>
    <span class="n">as</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span> <span class="n">resolve_sock</span><span class="p">{</span><span class="n">ioc</span><span class="p">};</span>
    <span class="n">as</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span> <span class="n">res</span><span class="p">{</span><span class="n">resolve_sock</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()};</span>

    <span class="n">am</span><span class="o">::</span><span class="n">client</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">protocol_version</span><span class="o">::</span><span class="n">v3_1_1</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">mqtt</span><span class="o">&gt;</span> <span class="n">amcl</span><span class="p">{</span>
        <span class="n">ioc</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()</span> <span class="c1">// args for underlying layer (mqtt)</span>
        <span class="c1">// mqtt is as::basic_stream_socket&lt;as::ip::tcp, as::io_context::executor_type&gt;</span>
    <span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mqtts">mqtts</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">as</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ioc</span><span class="p">;</span>

    <span class="c1">// To get IP address from hostname</span>
    <span class="n">as</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span> <span class="n">resolve_sock</span><span class="p">{</span><span class="n">ioc</span><span class="p">};</span>
    <span class="n">as</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span> <span class="n">res</span><span class="p">{</span><span class="n">resolve_sock</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()};</span>

    <span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">context</span> <span class="n">ctx</span><span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">tlsv12</span><span class="p">};</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">set_verify_mode</span><span class="p">(</span><span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">verify_none</span><span class="p">);</span>
    <span class="c1">// If you want to check server certificate, set cacert as follows.</span>
    <span class="c1">// ctx.load_verify_file(cacert);</span>

    <span class="n">am</span><span class="o">::</span><span class="n">client</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">protocol_version</span><span class="o">::</span><span class="n">v5</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">mqtts</span><span class="o">&gt;</span> <span class="n">amcl</span><span class="p">{</span>
        <span class="n">ioc</span><span class="p">.</span><span class="n">get_executor</span><span class="p">(),</span>  <span class="c1">// args for underlying layer (as::ssl::stream&lt;mqtt&gt;)</span>
        <span class="n">ctx</span>
    <span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>tls</code> is namespace alias of <code>boost::asio::ssl</code> by default.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ws">ws</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">as</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ioc</span><span class="p">;</span>

    <span class="c1">// To get IP address from hostname</span>
    <span class="n">as</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span> <span class="n">resolve_sock</span><span class="p">{</span><span class="n">ioc</span><span class="p">};</span>
    <span class="n">as</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span> <span class="n">res</span><span class="p">{</span><span class="n">resolve_sock</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()};</span>

    <span class="n">am</span><span class="o">::</span><span class="n">client</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">protocol_version</span><span class="o">::</span><span class="n">v3_1_1</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">ws</span><span class="o">&gt;</span> <span class="n">amcl</span><span class="p">{</span>
    <span class="k">auto</span> <span class="n">amep</span> <span class="o">=</span> <span class="n">am</span><span class="o">::</span><span class="n">endpoint</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">role</span><span class="o">::</span><span class="n">client</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">ws</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">(</span>
        <span class="n">ioc</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()</span>  <span class="c1">// args for underlying layer (bs::websocket::stream&lt;mqtt&gt;)</span>
    <span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wss">wss</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">as</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ioc</span><span class="p">;</span>

    <span class="c1">// To get IP address from hostname</span>
    <span class="n">as</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span> <span class="n">resolve_sock</span><span class="p">{</span><span class="n">ioc</span><span class="p">};</span>
    <span class="n">as</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span> <span class="n">res</span><span class="p">{</span><span class="n">resolve_sock</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()};</span>

    <span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">context</span> <span class="n">ctx</span><span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">tlsv12</span><span class="p">};</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">set_verify_mode</span><span class="p">(</span><span class="n">am</span><span class="o">::</span><span class="n">tls</span><span class="o">::</span><span class="n">verify_none</span><span class="p">);</span>
    <span class="c1">// If you want to check server certificate, set cacert as follows.</span>
    <span class="c1">// ctx.load_verify_file(cacert);</span>

    <span class="n">am</span><span class="o">::</span><span class="n">client</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">protocol_version</span><span class="o">::</span><span class="n">v3_1_1</span><span class="p">,</span> <span class="n">am</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">wss</span><span class="o">&gt;</span> <span class="n">amcl</span><span class="p">{</span>
        <span class="n">ioc</span><span class="p">.</span><span class="n">get_executor</span><span class="p">(),</span>  <span class="c1">// args for underlying layer ( bs::websocket::stream&lt;mqtts&gt;)</span>
        <span class="n">ctx</span>                  <span class="c1">// mqtts is as::ssl::stream&lt;mqtt&gt;</span>
    <span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_layer_access">Layer access</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Layer access</th>
<th class="tableblock halign-left valign-top">mqtt</th>
<th class="tableblock halign-left valign-top">mqtts</th>
<th class="tableblock halign-left valign-top">ws</th>
<th class="tableblock halign-left valign-top">wss</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">next_layer()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLS stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">next_layer().next_layer()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLS stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">next_layer().next_layer().next_layer()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lowest_layer()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP stream</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_handshaking_underlying_layer">Handshaking underlying layer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use underlying handshaking functions as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Underlying TCP connect</span>
<span class="k">co_await</span> <span class="n">as</span><span class="o">::</span><span class="n">async_connect</span><span class="p">(</span>
    <span class="n">amcl</span><span class="p">.</span><span class="n">next_layer</span><span class="p">(),</span>
    <span class="n">eps</span><span class="p">,</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"TCP connected"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, handshake TLS, WebSocket layers if needed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_send_mqtt_connect_packet_and_start_receive_loop">Send MQTT CONNECT packet and start receive loop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After underlying layers' handshaking is completed, then start MQTT layer connection.</p>
</div>
<div class="sect2">
<h3 id="_start_funtion"><a href="../api/classasync__mqtt_1_1basic__client.html#a64c2b201c643fabc568865933b681f80">start()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT connect and receive loop start</span>
<span class="k">auto</span> <span class="n">connack_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">start</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">connect_packet</span><span class="p">{</span>
        <span class="nb">true</span><span class="p">,</span>   <span class="c1">// clean_session</span>
        <span class="mh">0x1234</span><span class="p">,</span> <span class="c1">// keep_alive</span>
        <span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"cid1"</span><span class="p">),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="c1">// will</span>
        <span class="n">am</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="c1">// username set like allocate_buffer("user1"),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">nullopt</span>  <span class="c1">// password set like allocate_buffer("pass1")</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">connack_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">connack_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>CompletionToken parameters are error_code and connack_packet (optional). connack_packet has a value only if error_code is success. When you use CompletionToken such as <code>as::use_awaitable</code>, <code>as::use_future</code>, <code>as::deferred</code>, the first error_code is converted to exception. If you want to have the error_code as the return value, you can do as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT connect and receive loop start</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">ec</span><span class="p">,</span> <span class="n">connack_opt</span><span class="p">]</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">start</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">connect_packet</span><span class="p">{</span>
        <span class="nb">true</span><span class="p">,</span>   <span class="c1">// clean_session</span>
        <span class="mh">0x1234</span><span class="p">,</span> <span class="c1">// keep_alive</span>
        <span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"cid1"</span><span class="p">),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="c1">// will</span>
        <span class="n">am</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="c1">// username set like allocate_buffer("user1"),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">nullopt</span>  <span class="c1">// password set like allocate_buffer("pass1")</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">as_tuple</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">connack_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">connack_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_send_subscribeunsubscribe_and_wait_subackunsuback">Send SUBSCRIBE/UNSUBSCRIBE and wait SUBACK/UNSUBACK</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_subscribe_funtion"><a href="../api/classasync__mqtt_1_1basic__client.html#ae74159d835dca15f87b760b53acb4d51">subscribe()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// subscribe</span>
<span class="c1">// MQTT send subscribe and wait suback</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">topic_subopts</span><span class="o">&gt;</span> <span class="n">sub_entry</span><span class="p">{</span>
    <span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic1"</span><span class="p">),</span> <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_most_once</span><span class="p">},</span>
    <span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic2"</span><span class="p">),</span> <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_least_once</span><span class="p">},</span>
    <span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic3"</span><span class="p">),</span> <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">exactly_once</span><span class="p">},</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="n">suback_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">subscribe_packet</span><span class="p">{</span>
        <span class="o">*</span><span class="n">amcl</span><span class="p">.</span><span class="n">acquire_unique_packet_id</span><span class="p">(),</span> <span class="c1">// sync version only in strand</span>
        <span class="n">am</span><span class="o">::</span><span class="n">force_move</span><span class="p">(</span><span class="n">sub_entry</span><span class="p">)</span> <span class="c1">// sub_entry variable is required to avoid g++ bug</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">suback_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">suback_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>CompletionToken parameters are error_code and suback_packet (optional). suback_packet has a value only if error_code is success.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unsubscribe_funtion"><a href="../api/classasync__mqtt_1_1basic__client.html#a0ff1b5b724340a3df4c9ce9fab7a4b90">unsubscribe()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT send unsubscribe and wait unsuback</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">am</span><span class="o">::</span><span class="n">topic_sharename</span><span class="o">&gt;</span> <span class="n">unsub_entry</span><span class="p">{</span>
    <span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic1"</span><span class="p">)},</span>
    <span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic2"</span><span class="p">)},</span>
    <span class="p">{</span><span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic3"</span><span class="p">)},</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">unsuback_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">unsubscribe</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">unsubscribe_packet</span><span class="p">{</span>
        <span class="o">*</span><span class="n">amcl</span><span class="p">.</span><span class="n">acquire_unique_packet_id</span><span class="p">(),</span> <span class="c1">// sync version only in strand</span>
        <span class="n">am</span><span class="o">::</span><span class="n">force_move</span><span class="p">(</span><span class="n">unsub_entry</span><span class="p">)</span> <span class="c1">// unsub_entry variable is required to avoid g++ bug</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">unsuback_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">unsuback_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>CompletionToken parameters are error_code and unsuback_packet (optional). unsuback_packet has a value only if error_code is success.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_send_publish_packet_and_wait_response">Send PUBLISH packet and wait response</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_publish_funtion"><a href="../api/classasync__mqtt_1_1basic__client.html#ab6bed9cb83ac66b7bcb8595941edae4c">publish()</a> funtion</h3>
<div class="paragraph">
<p>Here is a code example that sending QoS0 PUBLISH packet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT publish QoS0 and wait response (socket write complete)</span>
<span class="k">auto</span> <span class="n">pubres0</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">publish_packet</span><span class="p">{</span>
        <span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic1"</span><span class="p">),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"payload1"</span><span class="p">),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_most_once</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>CompletionToken parameters are error_code and <a href="../api/structasync__mqtt_1_1basic__client_1_1pubres__t.html">pubres_t</a>.
When you send QoS0 PUBLISH packet, no response packet is expected, so the CompletionToken is invoked when underlying layer&#8217;s async_write operation is finished.
All the members of pubres_t are nullopt.</p>
</div>
<div class="paragraph">
<p>Here is a code example that sending QoS1 PUBLISH packet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT publish QoS1 and wait response (puback receive)</span>
<span class="k">auto</span> <span class="n">pid_pub1_opt</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">acquire_unique_packet_id</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span> <span class="c1">// async version</span>
<span class="k">auto</span> <span class="n">pubres1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">publish_packet</span><span class="p">{</span>
        <span class="o">*</span><span class="n">pid_pub1_opt</span><span class="p">,</span>
        <span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic2"</span><span class="p">),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"payload2"</span><span class="p">),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">at_least_once</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to create QoS1 PUBLISH packet, you need to acquire packet identifier. The example code above uses <a href="../api/classasync__mqtt_1_1basic__client.html#aa5a37f75664bb4dd8b883e464f2016e5">acquire_unique_packet_id()</a>. This is asynchnorous version. You can call it form anywhere you want. If all packet id is acquired, the CompletionToken parameter is nullopt. For convenience, sync version <a href="../api/classasync__mqtt_1_1basic__client.html#acaea92142dca0924af36e5acef91d8bb">acquire_unique_packet_id()</a> exists. When you use callback function approach, it could help keep the code simple. Sync version must be called in the client&#8217;s strand. For example, anywhare in the callback function that is registered to client member functions as a CompletionToken(CompletionHandler).</p>
</div>
<div class="paragraph">
<p>After publish() is completer, puback_opt of <a href="../api/structasync__mqtt_1_1basic__client_1_1pubres__t.html">pubres_t</a> is set. You can get puback packet.</p>
</div>
<div class="paragraph">
<p>Here is a code example that sending QoS1 PUBLISH packet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// MQTT publish QoS2 and wait response (pubrec, pubcomp receive)</span>
<span class="k">auto</span> <span class="n">pid_pub2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">acquire_unique_packet_id_wait_until</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span> <span class="c1">// async version</span>
<span class="k">auto</span> <span class="n">pubres2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">publish_packet</span><span class="p">{</span>
        <span class="n">pid_pub2</span><span class="p">,</span>
        <span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"topic3"</span><span class="p">),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">allocate_buffer</span><span class="p">(</span><span class="s">"payload3"</span><span class="p">),</span>
        <span class="n">am</span><span class="o">::</span><span class="n">qos</span><span class="o">::</span><span class="n">exactly_once</span>
    <span class="p">},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to create QoS2 PUBLISH packet, you need to acquire packet identifier. In this example, <a href="../api/classasync__mqtt_1_1basic__client.html#afbc77b4e603db0c1141d3235c8fa8b35">acquire_unique_packet_id_wait_until()</a> is used. The CompletionToken parameter is packet identifier that not optional. If all packet identifiers are used, the function waits at least one of the packet identifier becomes usable again, and then invokes CompletionToken. It can help keeping user code simple.</p>
</div>
<div class="paragraph">
<p>After publish() is completer, pubrec_opt and pubcomp_opt of <a href="../api/structasync__mqtt_1_1basic__client_1_1pubres__t.html">pubres_t</a> are set. You can get pubrec and pubcomp packet.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_receive_publish_packet_from_the_broker">Receive PUBLISH packet from the broker</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_recv_funtion"><a href="../api/classasync__mqtt_1_1basic__client.html#aad1963132aa1d0c6458bd6f38d9b7e48">recv()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="p">[</span><span class="n">publish_opt</span><span class="p">,</span> <span class="n">disconnect_opt</span><span class="p">]</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">publish_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">publish_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">disconnect_opt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">disconnect_opt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After you called start() function, the received PUBLISH packets are stored in the clinet. You can get it using recv() function. If the no packets are stored, recv() waits until PUBLISH packet would be received.</p>
</div>
<div class="paragraph">
<p>CompletionToken parameters are error_code and publish_packet (optional), and disconnect_packet(optional). publish_packet or disconnect_packet has a value only if error_code is success.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_send_disconnect_packet">Send DISCONNECT packet</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_disconnect_funtion"><a href="../api/classasync__mqtt_1_1basic__client.html#a13400c20164b4e0d2ed4d295cd6413d0">disconnect()</a> funtion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">disconnect</span><span class="p">(</span>
    <span class="n">am</span><span class="o">::</span><span class="n">v5</span><span class="o">::</span><span class="n">disconnect_packet</span><span class="p">{},</span>
    <span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>CompletionToken parameters is error_code.
Sending DISCONNECT packet to the broker starts a glaceful disconnect sequence. The broker sends MQTT will message if needed and then disconnect the network connection from the broker side. And then, the client detects the disconnection, finally close the client side socket.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_close">Close</h2>
<div class="sectionbody">
<div class="sect3">
<h4 id="_close_funtion"><a href="../api/classasync__mqtt_1_1basic__client.html#a4758d075939de30c77f3f4bdf0f7a4e1">close()</a> funtion</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">amcl</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="n">as</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>CompletionToken parameters is nothing.
If you want to close the socket forcibly, you can call close() function. For example, no packets are received from the broker unexpectedly, but the client side doesn&#8217;t detect disconnection.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whole_code">Whole code</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="../../example/cl_cpp20coro_mqtt.cpp">cl_cpp20coro_mqtt.cpp</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_supported_functionality">Supported Functionality</h2>
<div class="sectionbody">
<div class="paragraph">
<p>client supports the following functionalities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../functionality/connect_timeout.html">Connect Timeout</a></p>
</li>
<li>
<p><a href="../functionality/keep_session.html">Keep Session</a></p>
</li>
<li>
<p><a href="../functionality/topic_alias.html">Topic Alias</a></p>
</li>
<li>
<p><a href="../functionality/request_response.html">Request Response</a></p>
</li>
<li>
<p><a href="../functionality/receive_maximum.html">Receive Maximum</a></p>
</li>
<li>
<p><a href="../functionality/maximum_packet_size.html">Maximum Packet Size</a></p>
</li>
<li>
<p><a href="../logging.html">Logging</a></p>
</li>
</ul>
</div>
<div id="navigation">
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-middle"><a href="../trial.html">Prev</a></th>
<th class="tableblock halign-center valign-middle"><a href="../index.html">Up</a><br>
<a href="../index.html">Home</a></th>
<th class="tableblock halign-right valign-middle"><a href="create_endpoint.html">Next</a></th>
</tr>
</thead>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>